<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>SOSEJ - DOJO MODE</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Lexend+Mega:wght@700&display=swap");

      :root {
        --bg-color: #ffdcb6;
        --main-accent: #ff5e5e; /* Hot Red */
        --sec-accent: #5e6dff; /* Blue */
        --border-color: #121212;
        --shadow-offset: 6px;
        --border-width: 4px;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #1a1a1a;
        font-family: "Space Mono", monospace;
        cursor: crosshair;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* --- CUSTOM SCROLLBAR (MAXIMUM CHONK) --- */
      /* Firefox */
      * {
        scrollbar-width: thin;
        scrollbar-color: var(--main-accent) #ffffff;
      }

      /* Chrome, Edge, and Safari */
      ::-webkit-scrollbar {
        width: 32px;
        height: 32px;
      }

      ::-webkit-scrollbar-track {
        background: #ffffff;
        border-left: 4px solid var(--border-color);
      }

      ::-webkit-scrollbar-thumb {
        background-color: var(--main-accent);
        border: 6px solid var(--border-color);
        min-height: 50px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background-color: var(--sec-accent);
      }

      /* --- NEO-BRUTALIST UI UTILS --- */
      .nb-box {
        background: #fff;
        border: var(--border-width) solid var(--border-color);
        box-shadow: var(--shadow-offset) var(--shadow-offset) 0px
          var(--border-color);
        padding: 1rem;
        color: var(--border-color);
      }

      .nb-btn {
        background: var(--sec-accent);
        color: white;
        border: var(--border-width) solid var(--border-color);
        box-shadow: var(--shadow-offset) var(--shadow-offset) 0px
          var(--border-color);
        padding: 15px 30px;
        font-family: "Lexend Mega", sans-serif;
        font-size: 1.2rem;
        cursor: pointer;
        text-transform: uppercase;
        transition:
          transform 0.1s,
          box-shadow 0.1s;
      }

      .nb-btn:active:not(:disabled) {
        transform: translate(var(--shadow-offset), var(--shadow-offset));
        box-shadow: 0 0 0 transparent;
      }

      .nb-btn:disabled {
        background: #888;
        color: #ddd;
        cursor: not-allowed;
        opacity: 1;
      }

      /* --- LAYOUTS --- */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* TOP HUD */
      .hud-top {
        display: flex;
        justify-content: space-between;
        padding: 20px;
        gap: 20px;
        width: 100%;
        box-sizing: border-box;
      }

      .health-wrapper {
        width: 45%;
        position: relative;
      }

      .health-track {
        height: 30px;
        background: #fff;
        border: var(--border-width) solid var(--border-color);
        box-shadow: 4px 4px 0px var(--border-color);
        position: relative;
      }

      .health-fill {
        height: 100%;
        width: 100%;
        background: var(--main-accent);
        transition: width 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        border-right: 4px solid black;
      }

      .p-name {
        position: absolute;
        top: -25px;
        font-weight: 900;
        font-size: 14px;
        background: black;
        color: white;
        padding: 2px 8px;
        transform: skewX(-10deg);
      }

      /* BRAIN VISUALIZER (AI DEBUG) */
      #brain-container {
        position: absolute;
        top: 100px;
        right: 20px;
        width: 280px;
        max-height: 60vh;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        pointer-events: auto;
        z-index: 50;
        font-family: "Space Mono", monospace;
        font-size: 10px;
      }

      #brain-toggle {
        background: #000;
        color: #0f0;
        border: 2px solid #0f0;
        padding: 5px 10px;
        cursor: pointer;
        margin-bottom: 5px;
        font-weight: bold;
        box-shadow: 4px 4px 0 #0f0;
        transition: 0.1s;
      }
      #brain-toggle:active {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 #0f0;
      }

      #brain-panel {
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #0f0;
        width: 100%;
        padding: 10px;
        display: none;
        color: #0f0;
        box-shadow: 6px 6px 0 #000;
        overflow-y: auto;
      }

      .q-row {
        display: flex;
        justify-content: space-between;
        border-bottom: 1px solid #333;
        padding: 4px 0;
      }
      .q-row.active-state {
        background: #004400;
        color: #fff;
        font-weight: bold;
      }
      .q-state {
        width: 65%;
        overflow: hidden;
        white-space: nowrap;
      }
      .q-best-action {
        width: 35%;
        text-align: right;
        color: #ff0;
      }
      .q-val {
        width: 25%;
        text-align: right;
        display: none; /* Hide Q-Val in NN Agent view */
      }

      /* --- SCREENS --- */
      #character-select,
      #training-overlay,
      #end-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100dvh;
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        overflow-y: scroll; /* Forces scrollbar */
        padding: 20px 0;
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }

      #character-select::before,
      #training-overlay::before,
      #end-screen::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 220, 182, 0.95);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: -1;
      }

      #training-overlay {
        background: #000;
        color: #0f0;
        font-family: "Space Mono", monospace;
        justify-content: center;
      }
      #training-overlay::before {
        background: #000;
        backdrop-filter: none;
      }

      h1 {
        font-family: "Lexend Mega", sans-serif;
        font-size: clamp(2.5rem, 6vw, 5rem);
        margin: 20px 0;
        text-transform: uppercase;
        text-shadow: 4px 4px 0px rgba(0, 0, 0, 0.2);
        text-align: center;
        line-height: 0.9;
        flex-shrink: 0;
      }

      .char-grid {
        display: flex;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
        padding: 0 20px;
        max-width: 1000px;
        flex-shrink: 0;
      }

      .char-card {
        width: 150px;
        cursor: pointer;
        transition: transform 0.2s;
        text-align: center;
        flex-shrink: 0;
      }
      .char-card:hover {
        transform: translateY(-5px);
      }
      .char-card.selected {
        background: var(--main-accent);
        color: white;
      }

      .char-icon {
        font-size: 3rem;
        display: block;
        margin-bottom: 5px;
      }
      .char-name {
        font-weight: 700;
        display: block;
        margin-bottom: 5px;
        text-transform: uppercase;
        font-size: 0.9rem;
      }
      .stat-bar {
        background: rgba(0, 0, 0, 0.2);
        height: 6px;
        width: 100%;
        margin: 4px 0;
        position: relative;
      }
      .stat-val-bar {
        height: 100%;
        background: currentColor;
      }

      /* TRAINING TERMINAL */
      .terminal-box {
        border: 2px solid #0f0;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        background: #111;
        box-shadow: 8px 8px 0 #004400;
      }

      /* JOYSTICK */
      #joystick-zone {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        width: 140px;
        height: 140px;
        background: rgba(255, 255, 255, 0.2);
        border: 4px solid rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        z-index: 50;
        pointer-events: auto;
        display: none;
        touch-action: none;
      }

      #joystick-knob {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        background: var(--main-accent);
        border: 4px solid #000;
        border-radius: 50%;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
      }

      .tap-hint {
        position: absolute;
        bottom: 100px;
        width: 100%;
        text-align: center;
        font-weight: bold;
        font-size: 12px;
        opacity: 0.5;
        display: none;
      }

      .dmg-popup {
        position: absolute;
        font-family: "Lexend Mega", sans-serif;
        font-weight: 900;
        color: #fff;
        text-shadow: 3px 3px 0 #000;
        font-size: 24px;
        pointer-events: none;
        animation: popUp 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        z-index: 15;
      }

      @keyframes popUp {
        0% {
          transform: scale(0.5) translateY(0);
          opacity: 0;
        }
        50% {
          transform: scale(1.2) translateY(-20px);
          opacity: 1;
        }
        100% {
          transform: scale(1) translateY(-50px);
          opacity: 0;
        }
      }

      /* START BUTTON (Robust Positioning) */
      #start-btn {
        position: fixed;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999; /* Higher than everything */
        pointer-events: auto;
        box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.5);
      }

      /* --- BGM WIDGET --- */
      .bgm-container {
        display: flex;
        justify-content: center;
        width: 100%;
        margin-top: 30px;
        z-index: 50;
      }

      .bgm-widget {
        display: flex;
        align-items: center;
        background: #fff;
        border: var(--border-width) solid var(--border-color);
        box-shadow: var(--shadow-offset) var(--shadow-offset) 0px
          var(--border-color);
        padding: 0;
        height: 48px;
        transition: transform 0.2s;
        max-width: 90vw;
      }

      .bgm-info {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 20px;
        font-weight: bold;
        font-size: 0.9rem;
        color: var(--border-color);
        white-space: nowrap;
        flex-grow: 1;
      }

      .bgm-viz {
        display: flex;
        gap: 4px;
        align-items: flex-end;
        height: 24px;
        padding-bottom: 2px;
      }

      .viz-bar {
        width: 6px;
        background: var(--main-accent);
        height: 20%;
        /* Animation is paused by default, running when active */
        animation: vizBounce 0.6s infinite alternate;
        animation-play-state: paused;
      }
      .viz-bar:nth-child(1) {
        animation-delay: 0s;
      }
      .viz-bar:nth-child(2) {
        animation-delay: 0.2s;
      }
      .viz-bar:nth-child(3) {
        animation-delay: 0.4s;
      }

      .viz-bar.active {
        animation-play-state: running;
      }

      @keyframes vizBounce {
        0% {
          height: 20%;
        }
        100% {
          height: 100%;
        }
      }

      .bgm-upload-trigger {
        width: 0;
        overflow: hidden;
        background: var(--sec-accent);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        transition:
          width 0.3s ease,
          padding 0.3s ease;
        cursor: pointer;
        white-space: nowrap;
        font-family: "Lexend Mega", sans-serif;
        font-size: 0.8rem;
        border-left: 0px solid var(--border-color);
      }

      .bgm-widget:hover .bgm-upload-trigger {
        width: 140px;
        padding: 0 10px;
        border-left: var(--border-width) solid var(--border-color);
      }

      .bgm-upload-trigger:hover {
        background: #4a5ae0;
      }

      /* --- MOBILE RESPONSIVE TWEAKS --- */
      @media (max-width: 768px) {
        h1 {
          font-size: 2.5rem;
          margin-top: 40px;
        }

        #character-select {
          justify-content: flex-start;
        }

        .hud-top {
          padding: 10px;
        }
        .p-name {
          font-size: 10px;
          top: -18px;
        }
        .health-track {
          height: 20px;
        }

        .char-card {
          width: 42vw;
          margin-bottom: 5px;
        }
        .char-grid {
          gap: 10px;
          padding-bottom: 160px;
        }

        #start-btn {
          bottom: 30px;
          width: 85%;
        }
      }
    </style>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script src="https://unpkg.com/brain.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <!-- UI LAYER -->
    <div id="ui-layer">
      <div class="hud-top" id="hud" style="opacity: 0">
        <div class="health-wrapper">
          <div class="p-name" id="p1-name-disp">YOU</div>
          <div
            class="health-track nb-box"
            style="
              padding: 0;
              border: 2px solid black;
              box-shadow: 4px 4px 0 #000;
            "
          >
            <div id="p1-fill" class="health-fill"></div>
          </div>
        </div>
        <div class="health-wrapper">
          <div
            class="p-name"
            id="p2-name-disp"
            style="right: 0; background: var(--sec-accent)"
          >
            AI_BOT
          </div>
          <div
            class="health-track nb-box"
            style="
              padding: 0;
              border: 2px solid black;
              box-shadow: 4px 4px 0 #000;
            "
          >
            <div
              id="p2-fill"
              class="health-fill"
              style="background: var(--sec-accent)"
            ></div>
          </div>
        </div>
      </div>

      <!-- Brain Visualizer -->
      <div id="brain-container">
        <button id="brain-toggle" onclick="toggleBrain()">
          SHOW BOT BRAIN
        </button>
        <div id="brain-panel">
          <div style="margin-bottom: 5px; border-bottom: 1px solid #0f0">
            STATE | Q-VALS
          </div>
          <div id="q-rows"></div>
        </div>
      </div>

      <div class="tap-hint" id="tap-hint">TAP RIGHT SIDE TO ATTACK</div>

      <div id="joystick-zone">
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- SCREENS -->
    <div id="character-select">
      <h1>SOSEJ</h1>
      <div class="char-grid" id="char-grid"></div>

      <!-- BGM WIDGET -->
      <div class="bgm-container">
        <input
          type="file"
          id="bgm-input"
          accept="audio/*"
          style="display: none"
        />
        <div class="bgm-widget">
          <div class="bgm-info">
            <div class="bgm-viz">
              <div class="viz-bar" id="vb1"></div>
              <div class="viz-bar" id="vb2"></div>
              <div class="viz-bar" id="vb3"></div>
            </div>
            <span id="bgm-label">CLICK TO START AUDIO</span>
          </div>
          <!-- Volume Slider -->
          <div style="display:flex; align-items:center; padding: 0 10px; border-left: 2px solid #000;">
             <span style="font-size:12px; font-weight:bold; margin-right:5px;">VOL</span>
             <input type="range" id="bgm-vol" min="0" max="1" step="0.05" value="0.2" style="width: 60px;">
          </div>
          <div class="bgm-upload-trigger" id="bgm-trigger">UPLOAD TRACK üìÇ</div>
        </div>
      </div>
    </div>

    <button id="start-btn" class="nb-btn" disabled>SELECT FIGHTER</button>

    <div id="training-overlay" style="display: none">
      <div class="terminal-box">
        <div style="border-bottom: 1px solid #0f0; margin-bottom: 10px">
          > SYSTEM_BOOT_SEQUENCE
        </div>
        <div id="training-log">> INITIALIZING NEURAL NET...</div>
        <div
          id="loading-bar"
          style="margin-top: 20px; width: 0%; height: 20px; background: #0f0"
        ></div>
        <div
          id="loss-log"
          style="margin-top: 10px; font-size: 12px; color: #ff0"
        >
          > epoch: 0, loss: 0.000
        </div>

        <div
          style="
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px dashed #004400;
            font-size: 11px;
            color: #0f0;
            line-height: 1.6;
            font-family: &quot;Space Mono&quot;, monospace;
          "
        >
          <div style="color: #fff; font-weight: bold; margin-bottom: 4px">
            >> PILOT_INSTRUCTIONS
          </div>
          <div>[CTRL] DRAG/JOYSTICK to Move. CLICK/TAP to Fire.</div>
          <div>
            [DMG] Damage = <span style="color: #ff5e5e">VELOCITY</span> x
            <span style="color: #ff5e5e">MASS</span>. Swing fast for heavy hits.
          </div>
          <div>[CRIT] Head impacts deal 2x damage. Protect your noodle.</div>
        </div>
      </div>
    </div>

    <div id="end-screen" style="display: none">
      <h1 id="end-title">VICTORY</h1>
      <button id="restart-btn" class="nb-btn">PLAY AGAIN</button>
    </div>

    <script type="module">
      import * as THREE from "three";

      // --- Config & Constants ---
      const AudioSys = {
        ctx: null,
        bgmSource: null,
        bgmGain: null,
        bgmEl: null,
        masterVol: 0.2,
        init: function () {
          if (this.ctx) return;
          window.AudioContext =
            window.AudioContext || window.webkitAudioContext;
          this.ctx = new AudioContext();
        },
        resume: function () {
          if (this.ctx && this.ctx.state === "suspended") {
            this.ctx.resume();
          }
        },
        setVolume: function(val) {
            this.masterVol = parseFloat(val);
            if (this.bgmGain) {
                this.bgmGain.gain.setValueAtTime(this.masterVol, this.ctx.currentTime);
            }
            if (this.bgmEl) {
                this.bgmEl.volume = this.masterVol;
            }
        },
        stopCurrentBGM: function () {
          if (this.bgmSource) {
            try {
              this.bgmSource.stop();
            } catch (e) {}
            this.bgmSource = null;
          }
          if (this.bgmEl) {
            this.bgmEl.pause();
            this.bgmEl.currentTime = 0;
            this.bgmEl = null;
          }
        },
        playBGM: async function (file) {
          this.init();
          this.resume();
          this.stopCurrentBGM();

          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);

          this.bgmSource = this.ctx.createBufferSource();
          this.bgmSource.buffer = audioBuffer;
          this.bgmSource.loop = true;

          this.bgmGain = this.ctx.createGain();
          this.bgmGain.gain.value = this.masterVol;

          this.bgmSource.connect(this.bgmGain);
          this.bgmGain.connect(this.ctx.destination);
          this.bgmSource.start(0);

          this.updateWidget(file.name, true);
        },
        playBGMFromUrl: function (url) {
          this.init();
          this.resume();

          if (this.bgmEl || this.bgmSource) return;

          // Use HTML5 Audio for local file robustness (avoids CORS/Fetch on file://)
          this.bgmEl = new Audio(url);
          this.bgmEl.loop = true;
          this.bgmEl.volume = this.masterVol;

          this.bgmEl
            .play()
            .then(() => {
              this.updateWidget("Pixelated Dreams.mp3", true);
            })
            .catch((e) => {
              console.error("BGM Autoplay prevented or file not found:", e);
              this.bgmEl = null;
              this.updateWidget("CLICK TO START BGM", false, true);
            });
        },
        updateWidget: function (text, isActive, isError = false) {
          const lbl = document.getElementById("bgm-label");
          if (lbl) {
            lbl.innerText =
              text.length > 25 ? text.substring(0, 22) + "..." : text;
            lbl.style.color = isError ? "#ff5e5e" : "var(--border-color)";
          }
          const bars = document.querySelectorAll(".viz-bar");
          bars.forEach((b) => {
            if (isActive) b.classList.add("active");
            else b.classList.remove("active");
          });
        },
        playTone: function (freq, type, duration, vol = 0.1) {
          if (!this.ctx) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          gain.gain.setValueAtTime(vol, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            this.ctx.currentTime + duration
          );
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        },
        playHit: function (isCrit) {
          if (!this.ctx) return;
          // Noise burst for impact
          const bufferSize = this.ctx.sampleRate * 0.1; // 100ms
          const buffer = this.ctx.createBuffer(
            1,
            bufferSize,
            this.ctx.sampleRate
          );
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          const noise = this.ctx.createBufferSource();
          noise.buffer = buffer;
          const gain = this.ctx.createGain();

          // Filter for "thud" vs "crack"
          const filter = this.ctx.createBiquadFilter();
          filter.type = isCrit ? "peaking" : "lowpass";
          filter.frequency.value = isCrit ? 1000 : 200;
          filter.Q.value = 1;

          gain.gain.setValueAtTime(isCrit ? 0.4 : 0.2, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            this.ctx.currentTime + 0.1
          );

          noise.connect(filter);
          filter.connect(gain);
          gain.connect(this.ctx.destination);
          noise.start();

          // punchy sine kick
          this.playTone(isCrit ? 150 : 60, "square", 0.15, isCrit ? 0.2 : 0.1);
        },
        playShoot: function () {
          if (!this.ctx) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.frequency.setValueAtTime(600, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            100,
            this.ctx.currentTime + 0.2
          );
          gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(this.ctx.currentTime + 0.2);
        },
        playSelect: function () {
          this.init();
          this.playTone(800, "sine", 0.1, 0.05);
        },
        playStart: function () {
          if (!this.ctx) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.frequency.setValueAtTime(200, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            600,
            this.ctx.currentTime + 0.5
          );
          gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(this.ctx.currentTime + 0.5);
        },
        playWin: function () {
          if (!this.ctx) return;
          const now = this.ctx.currentTime;
          [440, 554, 659, 880].forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = "triangle";
            osc.frequency.value = f;
            gain.gain.setValueAtTime(0, now + i * 0.1);
            gain.gain.linearRampToValueAtTime(0.1, now + i * 0.1 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.4);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(now + i * 0.1);
            osc.stop(now + i * 0.1 + 0.5);
          });
        },
        playLose: function () {
          if (!this.ctx) return;
          const now = this.ctx.currentTime;
          [300, 250, 200].forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = "sawtooth";
            osc.frequency.value = f;
            gain.gain.setValueAtTime(0.1, now + i * 0.3);
            gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.3 + 0.3);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(now + i * 0.3);
            osc.stop(now + i * 0.3 + 0.3);
          });
        },
      };

      const GRAVITY = -0.02;
      const FRICTION = 0.96;
      const SEGMENT_LENGTH = 0.55;
      const SAUSAGE_RADIUS = 0.65;
      const ITERATIONS = 40;
      const MAX_DAMAGE = 5;
      const I_FRAMES = 1500;

      // Neural Net Config
      const INPUT_SIZE = 10;
      const HIDDEN_LAYERS = [24, 16];
      const OUTPUT_SIZE = 9;
      const LEARNING_RATE = 0.005;
      const DISCOUNT_FACTOR = 0.95;

      // Self-Play Constants
      const POLICY_UPDATE_FREQUENCY = 500;

      // Curriculum Constants
      const TOTAL_TRAIN_FRAMES = 100000;
      const TRAIN_STEPS_FSM = 50000;
      const TRAIN_STEPS_SELFPLAY = TOTAL_TRAIN_FRAMES - TRAIN_STEPS_FSM;
      const EPOCH_FRAME_COUNT = 10000;

      // Responsive Bounds
      let WORLD_WIDTH = 36;
      let WORLD_HEIGHT = 20;

      const CHARACTERS = {
        frankfurter: {
          name: "Frank",
          icon: "üå≠",
          color: 0xffaaaa,
          segments: 8,
          weight: 1.0,
          responsiveness: 0.25,
          damage: 1.0,
          health: 100,
        },
        bratwurst: {
          name: "Brat",
          icon: "ü•ñ",
          color: 0xd2691e,
          segments: 12,
          weight: 1.8,
          responsiveness: 0.1,
          damage: 1.5,
          health: 140,
        },
        chorizo: {
          name: "Rizo",
          icon: "üå∂Ô∏è",
          color: 0xff0000,
          segments: 7,
          weight: 0.8,
          responsiveness: 0.35,
          damage: 1.2,
          health: 85,
          trait: "fire",
        },
        boudin: {
          name: "Boudin",
          icon: "‚ö™",
          color: 0xf5f5dc,
          segments: 9,
          weight: 1.1,
          responsiveness: 0.18,
          damage: 1.0,
          health: 110,
          trait: "fire",
        },
        salami: {
          name: "Salami",
          icon: "üçñ",
          color: 0x8b0000,
          segments: 8,
          weight: 1.2,
          responsiveness: 0.15,
          damage: 0.9,
          health: 120,
          trait: "projectile",
        },
      };

      // Expanded Action Space (9 actions)
      const ACTION_NAMES = [
        "CHARGE_FAR", // 0
        "RETREAT_FAR", // 1
        "HIGH_SWING", // 2
        "LOW_SWING", // 3
        "MID_CENTER", // 4
        "AGGRO_PUSH", // 5
        "JUMP_BAIT", // 6
        "SHOOT_MID", // 7
        "SNAP_CHARGE", // 8
      ];
      const ACTION_TARGETS = [
        { x: -2, y: -4 }, // 0: CHARGE_FAR (Deeply aggressive)
        { x: 18, y: -4 }, // 1: RETREAT_FAR (Max distance retreat)
        { x: 8, y: 4 }, // 2: HIGH_SWING (High position for offense/defense)
        { x: 8, y: -8 }, // 3: LOW_SWING (Low position for offense/defense)
        { x: 5, y: -4 }, // 4: MID_CENTER (Neutral, safe mid-range)
        { x: 1, y: -6 }, // 5: AGGRO_PUSH (Very close, low guard, high collision)
        { x: 10, y: 8 }, // 6: JUMP_BAIT (High jump for dodging or positioning)
        { x: 10, y: -4 }, // 7: SHOOT_MID (Mid-range stance for projectile users)
        { x: -5, y: -7 }, // 8: SNAP_CHARGE (Extremely aggressive, low to the ground)
      ];

      // --- Game State ---
      let gameActive = false;
      let p1Health = 100,
        p1MaxHealth = 100;
      let p2Health = 100,
        p2MaxHealth = 100;
      let playerSausage, botSausage, nnAgent;
      let projectiles = [];
      let isMobile = false;
      let slowMoTimer = 0;

      // Input
      const mouse = new THREE.Vector2();
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const raycaster = new THREE.Raycaster();

      // Joystick State
      const joystick = {
        active: false,
        dx: 0,
        dy: 0,
        originX: 0,
        originY: 0,
        currentX: 0,
        currentY: 0,
      };

      // --- Scene Setup ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f8ff);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 0, 24);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // --- Lighting ---
      const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      // Expand shadow camera frustum to cover the whole kitchen
      dirLight.shadow.camera.left = -50;
      dirLight.shadow.camera.right = 50;
      dirLight.shadow.camera.top = 50;
      dirLight.shadow.camera.bottom = -50;
      dirLight.shadow.camera.near = 0.5;
      dirLight.shadow.camera.far = 100;
      scene.add(dirLight);

      // --- Kitchen Environment ---
      function createCheckerTexture() {
        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = "#e0e0e0";
        const numTiles = 4;
        const tileSize = size / numTiles;
        for (let i = 0; i < numTiles; i++) {
          for (let j = 0; j < numTiles; j++) {
            if ((i + j) % 2 === 0) {
              ctx.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
            }
          }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.repeat.set(20, 20);
        return tex;
      }

      function setupKitchenEnvironment() {
        // Floor
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({
          map: createCheckerTexture(),
          roughness: 0.1,
          metalness: 0.0,
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -7.8;
        floor.receiveShadow = true;
        scene.add(floor);

        // Back Wall (Tiled)
        const wallGeo = new THREE.PlaneGeometry(200, 60);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xdcedc8 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.z = -15;
        wall.position.y = 10;
        wall.receiveShadow = true;
        scene.add(wall);

        // Countertop Block
        const counterGeo = new THREE.BoxGeometry(200, 8, 10);
        const counterMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
        const counter = new THREE.Mesh(counterGeo, counterMat);
        counter.position.set(0, -9, -15); // Base of the wall
        counter.receiveShadow = true;
        counter.castShadow = true;
        scene.add(counter);

        // --- Detailed Fridge ---
        const fridgeGroup = new THREE.Group();
        fridgeGroup.position.set(-25, 4, -12);

        // Main Body
        const fridgeBodyGeo = new THREE.BoxGeometry(10, 24, 8);
        const fridgeMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.2,
          metalness: 0.1,
        });
        const fridgeBody = new THREE.Mesh(fridgeBodyGeo, fridgeMat);
        fridgeBody.castShadow = true;
        fridgeBody.receiveShadow = true;
        fridgeGroup.add(fridgeBody);

        // Freezer Crack
        const lineGeo = new THREE.BoxGeometry(10.2, 0.2, 8.2);
        const lineMesh = new THREE.Mesh(
          lineGeo,
          new THREE.MeshBasicMaterial({ color: 0xcccccc })
        );
        lineMesh.position.y = 4;
        fridgeGroup.add(lineMesh);

        // Handles
        const handleGeo = new THREE.BoxGeometry(0.5, 4, 0.5);
        const handleMat = new THREE.MeshStandardMaterial({
          color: 0xc0c0c0,
          metalness: 0.8,
          roughness: 0.2,
        });

        const handleTop = new THREE.Mesh(handleGeo, handleMat);
        handleTop.position.set(3.5, 7, 4.2);
        fridgeGroup.add(handleTop);

        const handleBot = new THREE.Mesh(handleGeo, handleMat);
        handleBot.position.set(3.5, 1, 4.2);
        fridgeGroup.add(handleBot);

        scene.add(fridgeGroup);

        // --- Detailed Stove ---
        const stoveGroup = new THREE.Group();
        stoveGroup.position.set(25, -2, -12);

        // Main Body
        const stoveGeo = new THREE.BoxGeometry(10, 12, 8);
        const stoveMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const stove = new THREE.Mesh(stoveGeo, stoveMat);
        stove.castShadow = true;
        stoveGroup.add(stove);

        // Burners (4 cylinders)
        const burnerGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 16);
        const burnerMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const positions = [
          [-2.5, -2],
          [2.5, -2],
          [-2.5, 2],
          [2.5, 2],
        ];
        positions.forEach((pos) => {
          const b = new THREE.Mesh(burnerGeo, burnerMat);
          b.position.set(pos[0], 6.1, pos[1]);
          stoveGroup.add(b);
          // Red hot coil center
          const coil = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 0.22, 16),
            new THREE.MeshBasicMaterial({ color: 0x330000 })
          );
          coil.position.set(pos[0], 6.1, pos[1]);
          stoveGroup.add(coil);
        });

        // Oven Door Window
        const windowGeo = new THREE.PlaneGeometry(7, 5);
        const windowMat = new THREE.MeshStandardMaterial({
          color: 0x111111,
          roughness: 0.1,
          metalness: 0.5,
        });
        const ovenWindow = new THREE.Mesh(windowGeo, windowMat);
        ovenWindow.position.set(0, -1, 4.1);
        stoveGroup.add(ovenWindow);

        // Knobs Panel
        const panelGeo = new THREE.BoxGeometry(10, 2, 8.2);
        const panel = new THREE.Mesh(
          panelGeo,
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        panel.position.set(0, 4, 0);
        stoveGroup.add(panel);

        // Knobs
        const knobGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 8);
        const knobMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        for (let k = 0; k < 4; k++) {
          const knob = new THREE.Mesh(knobGeo, knobMat);
          knob.rotation.x = Math.PI / 2;
          knob.position.set(-3 + k * 2, 4, 4.3);
          stoveGroup.add(knob);
        }

        scene.add(stoveGroup);

        // --- Detailed Knife Rack ---
        const rackGroup = new THREE.Group();
        rackGroup.position.set(0, 5, -14.5);

        // Magnet Strip
        const rackGeo = new THREE.BoxGeometry(12, 1, 0.5);
        const rackMat = new THREE.MeshStandardMaterial({
          color: 0x555555,
          metalness: 0.7,
          roughness: 0.2,
        });
        const rack = new THREE.Mesh(rackGeo, rackMat);
        rackGroup.add(rack);

        // Knives
        const bladeMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          metalness: 0.8,
          roughness: 0.2,
        });
        const handleKGeo = new THREE.BoxGeometry(0.8, 1.8, 0.3);
        const handleKMat = new THREE.MeshStandardMaterial({ color: 0x3e2723 });

        // Knife 1 (Chef Knife)
        const k1 = new THREE.Group();

        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.lineTo(1.2, 0);
        shape.lineTo(0, 4.5);
        shape.lineTo(0, 0);

        const extrudeSettings = { depth: 0.05, bevelEnabled: false };
        const bladeGeo1 = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const blade1 = new THREE.Mesh(bladeGeo1, bladeMat);
        blade1.position.x = -0.6;
        blade1.position.y = 0.9;
        blade1.position.z = -0.025;
        k1.add(blade1);

        const h1 = new THREE.Mesh(handleKGeo, handleKMat);
        h1.position.y = 0;
        k1.add(h1);

        k1.position.set(-3, 0, 0.3);
        k1.rotation.z = 0.2;
        rackGroup.add(k1);

        // Knife 2 (Cleaver)
        const k2 = new THREE.Group();
        const cleaverGeo = new THREE.BoxGeometry(2, 3, 0.05);
        const cleaverBlade = new THREE.Mesh(cleaverGeo, bladeMat);
        cleaverBlade.position.y = 1.0;
        k2.add(cleaverBlade);

        const h2 = new THREE.Mesh(handleKGeo, handleKMat);
        h2.position.y = -0.5;
        k2.add(h2);

        k2.position.set(2, 0.5, 0.3);
        k2.rotation.z = -0.1;
        rackGroup.add(k2);

        scene.add(rackGroup);

        // --- Cutting Board ---
        const boardGeo = new THREE.BoxGeometry(6, 0.5, 4);
        const boardMat = new THREE.MeshStandardMaterial({ color: 0xd7ccc8 });
        const board = new THREE.Mesh(boardGeo, boardMat);
        board.position.set(-10, -4.7, -12); // On top of counter
        scene.add(board);
      }

      setupKitchenEnvironment();

      // --- Joystick Logic ---
      function initJoystick() {
        const zone = document.getElementById("joystick-zone");
        const knob = document.getElementById("joystick-knob");
        const maxDist = 40;

        if ("ontouchstart" in window || navigator.maxTouchPoints) {
          isMobile = true;
          zone.style.display = "block";
          document.getElementById("tap-hint").style.display = "block";
        }

        zone.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = zone.getBoundingClientRect();
            joystick.active = true;
            joystick.originX = rect.left + rect.width / 2;
            joystick.originY = rect.top + rect.height / 2;
            updateKnob(touch.clientX, touch.clientY);
          },
          { passive: false }
        );

        zone.addEventListener(
          "touchmove",
          (e) => {
            e.preventDefault();
            if (joystick.active) {
              const touch = e.changedTouches[0];
              updateKnob(touch.clientX, touch.clientY);
            }
          },
          { passive: false }
        );

        const resetJoystick = (e) => {
          e.preventDefault();
          joystick.active = false;
          joystick.dx = 0;
          joystick.dy = 0;
          knob.style.transform = `translate(-50%, -50%)`;
        };

        zone.addEventListener("touchend", resetJoystick);
        zone.addEventListener("touchcancel", resetJoystick);

        function updateKnob(cx, cy) {
          let dx = cx - joystick.originX;
          let dy = cy - joystick.originY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
          }
          knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
          joystick.dx = dx / maxDist;
          joystick.dy = -dy / maxDist;
        }
      }
      initJoystick();

      // Mobile Attack Tap
      window.addEventListener("touchstart", (e) => {
        if (
          gameActive &&
          playerSausage &&
          e.changedTouches[0].clientX > window.innerWidth / 2
        ) {
          const zone = document
            .getElementById("joystick-zone")
            .getBoundingClientRect();
          const t = e.changedTouches[0];
          // Check if touch is not inside the joystick zone
          if (!isTouchInRect(t, zone)) {
            playerSausage.shoot();
          }
        }
      });

      function isTouchInRect(touch, rect) {
        return (
          touch.clientX >= rect.left &&
          touch.clientX <= rect.right &&
          touch.clientY >= rect.top &&
          touch.clientY <= rect.bottom
        );
      }

      // Desktop Shooting Support
      window.addEventListener("mousedown", (e) => {
        if (gameActive && playerSausage) {
          playerSausage.shoot();
        }
      });

      // --- Particle System ---
      function createParticle(pos, color, size) {
        const geo = new THREE.BoxGeometry(size, size, size);
        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);

        // Random offset
        mesh.position.x += (Math.random() - 0.5) * 0.5;
        mesh.position.y += (Math.random() - 0.5) * 0.5;

        scene.add(mesh);

        let life = 20;
        function anim() {
          life--;
          mesh.position.y += 0.08; // Rise up
          mesh.rotation.z += 0.1;
          mesh.scale.multiplyScalar(0.9); // Shrink
          mat.opacity = life / 20;

          if (life > 0) requestAnimationFrame(anim);
          else {
            scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
          }
        }
        anim();
      }

      // --- Physics Engine ---
      class Point {
        constructor(x, y, z) {
          this.pos = new THREE.Vector3(x, y, 0);
          this.oldPos = new THREE.Vector3(x, y, 0);
          this.pinned = false;
        }
        update() {
          if (this.pinned) return;
          const vel = this.pos
            .clone()
            .sub(this.oldPos)
            .multiplyScalar(FRICTION);
          this.oldPos.copy(this.pos);
          this.pos.add(vel);
          this.pos.y += GRAVITY;
          this.pos.z *= 0.1;

          if (this.pos.y < -7) {
            this.pos.y = -7;
            const fX = this.pos.x - this.oldPos.x;
            this.oldPos.x = this.pos.x - fX * 0.5;
          }
        }
      }

      class Stick {
        constructor(p1, p2, length) {
          this.p1 = p1;
          this.p2 = p2;
          this.length = length;
        }
        update() {
          const dx = this.p2.pos.x - this.p1.pos.x;
          const dy = this.p2.pos.y - this.p1.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist === 0) return;
          const diff = this.length - dist;
          const percent = diff / dist / 2;
          const offsetX = dx * percent;
          const offsetY = dy * percent;
          if (!this.p1.pinned) {
            this.p1.pos.x -= offsetX;
            this.p1.pos.y -= offsetY;
          }
          if (!this.p2.pinned) {
            this.p2.pos.x += offsetX;
            this.p2.pos.y += offsetY;
          }
        }
      }

      // --- Entities ---
      class Sausage {
        constructor(scene, config, startX, isBot = false) {
          this.points = [];
          this.sticks = [];
          this.scene = scene;
          this.isBot = isBot;
          this.config = config;
          this.targetPos = new THREE.Vector3(startX, -4, 0);
          this.lastHitTime = 0;
          this.cooldown = 0;

          for (let i = 0; i < config.segments; i++) {
            this.points.push(new Point(startX, -4 + i * SEGMENT_LENGTH, 0));
          }
          for (let i = 0; i < this.points.length - 1; i++) {
            this.sticks.push(
              new Stick(this.points[i], this.points[i + 1], SEGMENT_LENGTH)
            );
          }
          // Cross-links for structural integrity (slightly reduced for performance)
          for (let i = 0; i < this.points.length - 2; i += 2) {
            this.sticks.push(
              new Stick(this.points[i], this.points[i + 2], SEGMENT_LENGTH * 2)
            );
          }
          // Stability links for the base (essential for control)
          const handleLen = Math.floor(config.segments * 0.4);
          for (let i = 0; i < handleLen; i++) {
            for (let j = i + 1; j < handleLen; j++) {
              const dist = SEGMENT_LENGTH * (j - i);
              this.sticks.push(new Stick(this.points[i], this.points[j], dist));
            }
          }

          const curve = new THREE.CatmullRomCurve3(
            this.points.map((p) => p.pos)
          );
          this.geometry = new THREE.TubeGeometry(
            curve,
            config.segments * 4,
            SAUSAGE_RADIUS,
            8,
            false
          );
          this.material = new THREE.MeshToonMaterial({
            color: config.color,
            emissive: 0x000000,
          });
          this.mesh = new THREE.Mesh(this.geometry, this.material);
          this.mesh.castShadow = true;
          scene.add(this.mesh);

          this.headMesh = new THREE.Mesh(
            new THREE.SphereGeometry(SAUSAGE_RADIUS * 1.0, 16, 16),
            new THREE.MeshToonMaterial({ color: isBot ? 0x222222 : 0xffffff })
          );
          this.headMesh.castShadow = true;
          this.buttMesh = new THREE.Mesh(
            new THREE.SphereGeometry(SAUSAGE_RADIUS * 0.98, 16, 16),
            this.material
          );
          scene.add(this.headMesh);
          scene.add(this.buttMesh);
        }

        getHeadPos() {
          return this.points[this.points.length - 1].pos;
        }

        shoot() {
          if (this.config.trait !== "projectile" || this.cooldown > 0) return;
          const head = this.getHeadPos();
          const neck = this.points[this.points.length - 2].pos;
          const dir = head.clone().sub(neck).normalize().multiplyScalar(0.9);
          projectiles.push({
            pos: head.clone(),
            vel: dir,
            mesh: new THREE.Mesh(
              new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8),
              new THREE.MeshBasicMaterial({ color: 0xff0000 })
            ),
            active: true,
            ownerIsBot: this.isBot,
            life: 100,
          });
          scene.add(projectiles[projectiles.length - 1].mesh);
          this.cooldown = 60;
          AudioSys.playShoot();
        }

        takeDamage(amount, hitPos = null) {
          // I-FRAMES CHECK (GLOBAL TIMESTAMP CHECK)
          if (Date.now() - this.lastHitTime < I_FRAMES) return false;

          this.lastHitTime = Date.now();

          // --- HARD CLAMP DAMAGE ---
          let actualDamage = Math.min(amount, MAX_DAMAGE);

          // --- TRIGGER SLOW MO ---
          slowMoTimer = 45; // ~0.75 seconds of slow mo

          // Visual Hit Feedback (Blink White)
          this.material.emissive.setHex(0xffffff);

          // Blink effect for I-Frames
          let blinkCount = 0;
          const blinkInterval = setInterval(() => {
            blinkCount++;
            if (blinkCount % 2 === 0) this.material.emissive.setHex(0x000000);
            else this.material.emissive.setHex(0x444444); // Dim gray

            if (Date.now() - this.lastHitTime >= I_FRAMES) {
              clearInterval(blinkInterval);
              this.material.emissive.setHex(0x000000);
            }
          }, 100);

          let reward = 0;
          if (this.isBot) {
            p2Health -= actualDamage;
            reward = -100;
          } else {
            p1Health -= actualDamage;
            reward = 120;
          }
          if (nnAgent) nnAgent.recordReward(reward);

          // Camera Shake
          const shake = Math.min(actualDamage * 0.2, 1.5);
          camera.position.x += (Math.random() - 0.5) * shake;
          camera.position.y += (Math.random() - 0.5) * shake;

          updateHealthUI();

          if (hitPos) showDamage(actualDamage, hitPos);
          AudioSys.playHit(actualDamage >= MAX_DAMAGE - 0.5);
          return true;
        }

        updatePhysics() {
          if (this.cooldown > 0) this.cooldown--;

          const base = this.points[0];
          const lerpFactor = this.isBot ? 0.08 : this.config.responsiveness;

          base.pos.lerp(this.targetPos, lerpFactor);
          base.pos.z = 0;
          base.pinned = true;

          this.points.forEach((p) => p.update());
          // 2 Iterations for stick constraint satisfaction
          for (let k = 0; k < 2; k++) this.sticks.forEach((s) => s.update());

          // Particle Emitter Logic
          if (this.config.trait === "fire") {
            if (Math.random() < 0.3) {
              createParticle(this.getHeadPos(), this.config.color, 0.5);
            }
          }
        }

        updateVisuals() {
          this.mesh.geometry.dispose();
          const curve = new THREE.CatmullRomCurve3(
            this.points.map((p) => p.pos)
          );
          this.mesh.geometry = new THREE.TubeGeometry(
            curve,
            this.config.segments * 4,
            SAUSAGE_RADIUS,
            12,
            false
          );
          this.headMesh.position.copy(this.points[this.points.length - 1].pos);
          this.buttMesh.position.copy(this.points[0].pos);
        }
      }

      // --- DEEP Q-NETWORK AGENT ---
      class NNAgent {
        constructor(bot, opp) {
          this.bot = bot;
          this.opp = opp;

          // Initialize brain.js Neural Network
          this.nn = new brain.NeuralNetwork({
            hiddenLayers: HIDDEN_LAYERS,
            learningRate: LEARNING_RATE,
          });

          this.nn.train(
            [
              {
                input: new Array(INPUT_SIZE).fill(0),
                output: new Array(OUTPUT_SIZE).fill(0),
              },
            ],
            {
              iterations: 1,
              errorThresh: 0.0001,
              log: false,
            }
          );

          this.epsilon = 1.0; // Start with high exploration
          // NOTE: Decay is managed in the bootstrap loop now to handle phase changes.
          this.epsilonMin = 0.05;

          this.lastState = null;
          this.lastAction = null;
          this.currentReward = 0;
          this.isTraining = true;
          this.epoch = 0;
        }

        // State representation: 10 normalized floats
        getState() {
          const b = this.bot.getHeadPos();
          const p = this.opp.getHeadPos();
          const pButt = this.opp.points[0].pos;
          const pMidIndex = Math.floor(this.opp.points.length * 0.5);
          const pMid = this.opp.points[pMidIndex].pos;

          const dx = p.x - b.x;
          const dy = p.y - b.y;

          // Helper to normalize relative coordinate/distance to the world scale
          const normX = (val) => Math.max(-1, Math.min(1, val / WORLD_WIDTH));
          const normY = (val) =>
            Math.max(-1, Math.min(1, val / (WORLD_HEIGHT / 2)));
          const normDist = (dist) =>
            Math.max(0, Math.min(1, dist / WORLD_WIDTH));

          // Base state features (Position of opponent's head relative to bot's head)
          const state = [
            normX(dx), // 0. Head Relative X
            normY(dy), // 1. Head Relative Y
            normDist(b.distanceTo(p)), // 2. Head Distance
            this.bot.points[0].pos.x / (WORLD_WIDTH / 2), // 3. Bot Base X Position
            p1Health / p1MaxHealth, // 4. Player Health Ratio
            p2Health / p2MaxHealth, // 5. Bot Health Ratio
          ];

          // Distance to Opponent's Middle Segment
          state.push(normDist(b.distanceTo(pMid))); // 6. Mid Dist
          // Distance to Opponent's Butt Segment
          state.push(normDist(b.distanceTo(pButt))); // 7. Butt Dist
          // Relative Y to Butt Segment
          state.push(normY(pButt.y - b.y)); // 8. Butt Relative Y
          // Relative Y to Mid Segment
          state.push(normY(pMid.y - b.y)); // 9. Mid Relative Y

          return state;
        }

        act(isTestMode = false) {
          const state = this.getState();
          // Use brain.js run method for forward propagation (prediction)
          const q_values = Array.from(this.nn.run(state));
          let actionIdx;

          if (this.isTraining && Math.random() < this.epsilon) {
            // Epsilon-Greedy: Explore (random action)
            actionIdx = Math.floor(Math.random() * OUTPUT_SIZE);
          } else {
            // Exploit (best predicted action)
            actionIdx = q_values.indexOf(Math.max(...q_values));
          }

          // Apply Action (Movement target)
          const act = ACTION_TARGETS[actionIdx];
          const pBase = this.opp.points[0].pos;

          this.bot.targetPos.x = THREE.MathUtils.lerp(
            this.bot.targetPos.x,
            pBase.x + act.x,
            0.12
          );
          this.bot.targetPos.y = THREE.MathUtils.lerp(
            this.bot.targetPos.y,
            act.y,
            0.12
          );

          // Training Step
          if (this.isTraining && this.lastState !== null) {
            this.train(state, q_values, actionIdx);
          }

          this.lastState = state;
          this.lastAction = actionIdx;
          this.currentReward = -0.1; // Living cost
        }

        // Training function
        train(newState, newQValues, actionIndex) {
          // 1. Get current Q-values for the action taken in the LAST state
          const oldQValues = Array.from(this.nn.run(this.lastState));

          // 2. Calculate the TD Target (Target Q-value)
          // Max predicted Q-value for the NEW state (max_a' Q(s', a'))
          const maxNextQ = Math.max(...newQValues);
          // Target Q-value: Reward + Gamma * maxNextQ
          const targetQ = this.currentReward + DISCOUNT_FACTOR * maxNextQ;

          // 3. Construct the full target vector: copy old Q values, but insert the new target Q for the action taken
          const target = [...oldQValues];
          target[this.lastAction] = targetQ; // Only update the Q-value for the action taken

          // 4. Train the network one step towards the target vector
          const stats = this.nn.train(
            [
              {
                input: this.lastState,
                output: target,
              },
            ],
            {
              iterations: 1, // only 1 iteration
              errorThresh: 0.0001,
              log: false, // Turn off logging
            }
          );

          // Return the error/loss for logging purposes
          return stats.error;
        }

        recordReward(r) {
          this.currentReward += r;
        }
      }

      /**
       * FSM Teacher Logic (Phase 1)
       */
      const FSM_TEACHER = {
        t: 0,
        s: "IDLE",
        update: function (bot, opp) {
          this.t++;
          // Slower state transition for stability (Phase 1)
          if (this.t > 40) {
            this.t = 0;
            const r = Math.random();
            // 50% chance to do something, 50% idle
            this.s = r < 0.5 ? "IDLE" : r < 0.75 ? "CHARGE" : "HIGH";
          }

          let tx = 8,
            ty = -4;
          const pBase = opp.points[0].pos;

          if (this.s === "CHARGE") {
            // Aggressive forward movement
            tx = THREE.MathUtils.lerp(0, -2, Math.random());
            ty = THREE.MathUtils.lerp(-4, -6, Math.random());
          } else if (this.s === "HIGH") {
            // High attack stance
            tx = 8;
            ty = 4;
          }

          bot.targetPos.x = THREE.MathUtils.lerp(
            bot.targetPos.x,
            pBase.x + tx,
            0.1
          );
          bot.targetPos.y = THREE.MathUtils.lerp(bot.targetPos.y, ty, 0.1);
        },
      };

      /**
       * Self-Play Policy Logic (Phase 2)
       * This function makes the training opponent (tp) move based on the main agent's policy,
       * but mirrored and using a lagged copy of the network for stable self-play learning.
       * @param {Sausage} selfBot - The current learning bot (tb)
       * @param {Sausage} oppBot - The training opponent (tp)
       * @param {brain.NeuralNetwork} policy - The lagged neural network for the opponent
       */
      function selfPlayOpponentAct(selfBot, oppBot, policy) {
        // Get the state from the OPPONENT'S perspective (needs mirroring/inversion)
        const b = oppBot.getHeadPos();
        const p = selfBot.getHeadPos();
        const pButt = selfBot.points[0].pos;
        const pMidIndex = Math.floor(selfBot.points.length * 0.5);
        const pMid = selfBot.points[pMidIndex].pos;

        const dx = p.x - b.x;
        const dy = p.y - b.y;

        // Helper to normalize relative coordinate/distance to the world scale
        const normX = (val) => Math.max(-1, Math.min(1, val / WORLD_WIDTH));
        const normY = (val) =>
          Math.max(-1, Math.min(1, val / (WORLD_HEIGHT / 2)));
        const normDist = (dist) => Math.max(0, Math.min(1, dist / WORLD_WIDTH));

        // Base state features (Position of opponent's head relative to bot's head)
        const state = [
          normX(dx), // 0. Head Relative X
          normY(dy), // 1. Head Relative Y
          normDist(b.distanceTo(p)), // 2. Head Distance
          oppBot.points[0].pos.x / (WORLD_WIDTH / 2), // 3. Opponent Base X Position
          p2Health / p2MaxHealth, // 4. Opponent Health Ratio
          p1Health / p1MaxHealth, // 5. Self-Bot Health Ratio
        ];

        // Distance to Opponent's Middle Segment
        state.push(normDist(b.distanceTo(pMid))); // 6. Mid Dist
        // Distance to Opponent's Butt Segment
        state.push(normDist(b.distanceTo(pButt))); // 7. Butt Dist
        // Relative Y to Butt Segment
        state.push(normY(pButt.y - b.y)); // 8. Butt Relative Y
        // Relative Y to Mid Segment
        state.push(normY(pMid.y - b.y)); // 9. Mid Relative Y

        // Run opponent's policy on the mirrored state
        const q_values = Array.from(policy.run(state));
        const actionIdx = q_values.indexOf(Math.max(...q_values));

        // Apply Action (Movement target)
        const act = ACTION_TARGETS[actionIdx];

        // To ensure the opponent moves toward the learning bot (tb), we target relative to tb's position
        const tbBase = selfBot.points[0].pos;

        oppBot.targetPos.x = THREE.MathUtils.lerp(
          oppBot.targetPos.x,
          tbBase.x + act.x,
          0.12
        );
        oppBot.targetPos.y = THREE.MathUtils.lerp(
          oppBot.targetPos.y,
          act.y,
          0.12
        );
      }

      // --- UI Logic (Mostly Unchanged) ---
      const charGrid = document.getElementById("char-grid");
      const startBtn = document.getElementById("start-btn");
      let selectedCharKey = null;

      Object.entries(CHARACTERS).forEach(([key, data]) => {
        const card = document.createElement("div");
        card.className = "char-card nb-box";
        card.innerHTML = `
            <span class="char-icon">${data.icon}</span>
            <span class="char-name">${data.name}</span>
            <div class="stat-bar"><div class="stat-val-bar" style="width:${
              data.responsiveness * 250
            }%; color:#5e6dff"></div></div>
            <div class="stat-bar"><div class="stat-val-bar" style="width:${
              data.damage * 60
            }%; color:#ff5e5e"></div></div>
          `;
        card.onclick = () => {
          AudioSys.playSelect();
          document
            .querySelectorAll(".char-card")
            .forEach((c) => c.classList.remove("selected"));
          card.classList.add("selected");
          selectedCharKey = key;
          startBtn.disabled = false;
          startBtn.style.background = "#ff5e5e";
          startBtn.style.color = "white";
          startBtn.innerText = "INITIATE SEQUENCE";
        };
        charGrid.appendChild(card);
      });

      // Brain Visualizer Logic
      window.toggleBrain = () => {
        const p = document.getElementById("brain-panel");
        p.style.display = p.style.display === "none" ? "block" : "none";
      };

      function updateBrainUI() {
        const panel = document.getElementById("q-rows");
        if (
          document.getElementById("brain-panel").style.display === "none" ||
          !nnAgent
        )
          return;

        let html = "";

        // --- Display NN Info ---
        const state = nnAgent.getState();
        // Use brain.js run method for prediction
        const q_values_float32 = nnAgent.nn.run(state);
        const q_values = Array.from(q_values_float32);
        const bestIdx = q_values.indexOf(Math.max(...q_values));

        html += `<div style="border-bottom:1px solid #555; padding:5px; color:#fff; text-align:center;">
                EPSILON: ${nnAgent.epsilon.toFixed(2)} (${nnAgent.epsilon > 0.3 ? "CHAOS" : "FOCUS"})
            </div>`;

        // Current State Values
        html += `<div style="padding: 5px; background: #004400; font-weight: bold; color: white;">
            STATE [NORM]: R_X: ${state[0].toFixed(2)}, R_Y: ${state[1].toFixed(2)}, DIST: ${state[2].toFixed(2)}
            <br>MID_DIST: ${state[6].toFixed(2)}, BUTT_DIST: ${state[7].toFixed(2)}
            </div>`;

        // Action Q-Values
        html += `<div style="margin-top: 5px; padding: 5px; border-top: 1px solid #555;">
            PREDICTED Q-VALUES:
        </div>`;

        for (let i = 0; i < OUTPUT_SIZE; i++) {
          const isBest = i === bestIdx;
          const color = isBest ? "#ff0" : "#0f0";
          const rowClass = isBest ? "q-row active-state" : "q-row";
          html += `<div class="${rowClass}">
                <div class="q-state" style="color:${color}; width: 60%;">${ACTION_NAMES[i]}</div>
                <div class="q-best-action" style="color:white; font-size: 1.1em;">${q_values[i].toFixed(3)}</div>
                <div class="q-val"></div>
            </div>`;
        }

        panel.innerHTML = html;
      }

      startBtn.onclick = async () => {
        AudioSys.init();
        AudioSys.resume();
        AudioSys.playStart();
        document.getElementById("character-select").style.display = "none";
        // Button is outside now, so manually hide it
        startBtn.style.display = "none";

        document.getElementById("training-overlay").style.display = "flex";

        await bootstrap(selectedCharKey);

        document.getElementById("training-overlay").style.display = "none";
        document.getElementById("hud").style.opacity = 1;
        startGame(selectedCharKey);
      };

      document.getElementById("restart-btn").onclick = () => {
        location.reload();
      };

      // --- Training ---
      async function bootstrap(playerKey) {
        const log = document.getElementById("training-log");
        const lossLog = document.getElementById("loss-log");
        const keys = Object.keys(CHARACTERS);
        const botC = CHARACTERS[keys[Math.floor(Math.random() * keys.length)]];
        const pC = CHARACTERS[playerKey];

        // Temporary Sim Entities
        const tp = new Sausage(scene, pC, -5, false); // Opponent
        const tb = new Sausage(scene, botC, 5, true); // Main Learning Bot
        const agent = new NNAgent(tb, tp); // Main NNAgent

        // Initial hidden state
        tp.mesh.visible = false;
        tp.headMesh.visible = false;
        tp.buttMesh.visible = false;
        tb.mesh.visible = false;
        tb.headMesh.visible = false;
        tb.buttMesh.visible = false;

        const bar = document.getElementById("loading-bar");
        let currentFrame = 0;
        let totalLoss = 0;
        let lossCount = 0;
        let epoch = 0;
        const framesPerEpoch = EPOCH_FRAME_COUNT;

        // --- PHASE 1: FSM PRE-TRAINING ---
        log.innerHTML = `> PHASE 1/2: FSM PRE-TRAINING (${TRAIN_STEPS_FSM} steps)...`;
        const FSM_DECAY_RATE = 0.9998;
        agent.epsilon = 1.0; // Start high exploration

        await new Promise((resolve) => {
          function stepFSM() {
            for (let k = 0; k < 50; k++) {
              // Fast forward 50 steps per frame
              if (currentFrame++ >= TRAIN_STEPS_FSM) break;

              // Update Epsilon
              agent.epsilon = Math.max(
                agent.epsilonMin,
                agent.epsilon * FSM_DECAY_RATE
              );

              // Opponent control: Simple FSM
              FSM_TEACHER.update(tp, tb);

              // Simulate collision and reward
              const h1 = tp.getHeadPos(),
                h2 = tb.getHeadPos();
              if (h1.distanceTo(h2) < 2.5) {
                const v1 = tp.points[0].pos
                  .clone()
                  .sub(tp.points[0].oldPos)
                  .length();
                const v2 = tb.points[0].pos
                  .clone()
                  .sub(tb.points[0].oldPos)
                  .length();
                agent.recordReward(v2 > v1 ? 10 : -10);
              }

              // Main Bot acts and trains
              agent.act(false);

              tp.updatePhysics();
              tb.updatePhysics();

              const state = agent.getState();
              const q_values = Array.from(agent.nn.run(state));
              totalLoss += agent.train(state, q_values, agent.lastAction);
              lossCount++;
              agent.currentReward = -0.1;

              if (currentFrame % framesPerEpoch === 0) {
                epoch++;
                const avgLoss = totalLoss / lossCount;
                lossLog.innerHTML = `> epoch: ${epoch} (FSM), loss: ${avgLoss.toFixed(5)}, Epsilon: ${agent.epsilon.toFixed(3)}`;
                totalLoss = 0;
                lossCount = 0;
                FSM_TEACHER.t = 0; // Reset FSM periodically
              }
            }

            const pct = Math.round((currentFrame / TOTAL_TRAIN_FRAMES) * 100);
            bar.style.width = pct + "%";

            if (currentFrame < TRAIN_STEPS_FSM) requestAnimationFrame(stepFSM);
            else resolve();
          }
          stepFSM();
        });

        // --- PHASE 2: SELF-PLAY REFINEMENT ---
        log.innerHTML = `> PHASE 2/2: SELF-PLAY REFINEMENT (${TRAIN_STEPS_SELFPLAY} steps)...`;

        // --- Epsilon Curriculum Reset for Phase 2 ---
        const SELFPLAY_DECAY_RATE = 0.99995;
        agent.epsilon = 0.5; // Reset to moderate exploration for new target network

        // Initialize Opponent's Policy (Target Network for self-play lag)
        let opponentPolicyJSON = agent.nn.toJSON();
        const opponentNet = new brain.NeuralNetwork({
          hiddenLayers: HIDDEN_LAYERS,
          learningRate: LEARNING_RATE,
        });
        opponentNet.fromJSON(opponentPolicyJSON);
        let policyUpdateCounter = 0;

        // Reset logging for Phase 2
        totalLoss = 0;
        lossCount = 0;
        epoch = 0;

        await new Promise((resolve) => {
          function stepSelfPlay() {
            for (let k = 0; k < 50; k++) {
              // Fast forward 50 steps per frame
              if (currentFrame++ > TOTAL_TRAIN_FRAMES) break;

              // Update Epsilon (Slower decay)
              agent.epsilon = Math.max(
                agent.epsilonMin,
                agent.epsilon * SELFPLAY_DECAY_RATE
              );

              // --- SELF-PLAY: UPDATE OPPONENT POLICY ---
              if (policyUpdateCounter++ >= POLICY_UPDATE_FREQUENCY) {
                opponentPolicyJSON = agent.nn.toJSON(); // Clone current weights
                opponentNet.fromJSON(opponentPolicyJSON); // Update opponent brain
                policyUpdateCounter = 0;
              }

              // --- OPPONENT ACTS (Using Lagged Self-Policy) ---
              selfPlayOpponentAct(tb, tp, opponentNet);

              // Simulate collision and reward
              const h1 = tp.getHeadPos(),
                h2 = tb.getHeadPos();
              if (h1.distanceTo(h2) < 2.5) {
                const v1 = tp.points[0].pos
                  .clone()
                  .sub(tp.points[0].oldPos)
                  .length();
                const v2 = tb.points[0].pos
                  .clone()
                  .sub(tb.points[0].oldPos)
                  .length();
                agent.recordReward(v2 > v1 ? 10 : -10);
              }

              // --- MAIN BOT ACTS AND TRAINS ---
              agent.act(false);

              tp.updatePhysics();
              tb.updatePhysics();

              const state = agent.getState();
              const q_values = Array.from(agent.nn.run(state));
              totalLoss += agent.train(state, q_values, agent.lastAction);
              lossCount++;
              agent.currentReward = -0.1;

              if (currentFrame % framesPerEpoch === 0) {
                epoch++;
                const avgLoss = totalLoss / lossCount;
                lossLog.innerHTML = `> epoch: ${epoch} (Self-Play), loss: ${avgLoss.toFixed(5)}, Epsilon: ${agent.epsilon.toFixed(3)}`;
                totalLoss = 0;
                lossCount = 0;
              }
            }

            const pct = Math.round((currentFrame / TOTAL_TRAIN_FRAMES) * 100);
            bar.style.width = pct + "%";

            if (currentFrame <= TOTAL_TRAIN_FRAMES)
              requestAnimationFrame(stepSelfPlay);
            else resolve();
          }
          stepSelfPlay();
        });

        // --- Final Cleanup ---
        scene.remove(tp.mesh);
        scene.remove(tp.headMesh);
        scene.remove(tp.buttMesh);
        scene.remove(tb.mesh);
        scene.remove(tb.headMesh);
        scene.remove(tb.buttMesh);
        nnAgent = agent; // Transfer learned agent
        nnAgent.isTraining = false; // Stop initial training
      }

      // --- Game Functions ---
      function updateHealthUI() {
        const p1Pct = Math.max(0, (p1Health / p1MaxHealth) * 100);
        const p2Pct = Math.max(0, (p2Health / p2MaxHealth) * 100);
        document.getElementById("p1-fill").style.width = p1Pct + "%";
        document.getElementById("p2-fill").style.width = p2Pct + "%";
        if ((p1Health <= 0 || p2Health <= 0) && gameActive) endGame();
      }

      function endGame() {
        gameActive = false;
        if (p1Health > 0) AudioSys.playWin();
        else AudioSys.playLose();
        document.getElementById("end-screen").style.display = "flex";
        document.getElementById("end-title").innerText =
          p1Health > 0 ? "VICTORY" : "FATAL ERROR";
        document.getElementById("end-title").style.color =
          p1Health > 0 ? "#0f0" : "#f00";
      }

      function showDamage(amount, pos) {
        const div = document.createElement("div");
        div.className = "dmg-popup";
        div.innerText = Math.round(amount);

        const tempV = pos.clone();
        tempV.project(camera);
        div.style.left = (tempV.x * 0.5 + 0.5) * window.innerWidth + "px";
        div.style.top = (-(tempV.y * 0.5) + 0.5) * window.innerHeight + "px";

        if (amount >= MAX_DAMAGE - 0.5) {
          div.innerText = "CRIT!";
          div.style.color = "#ff0055";
        } else {
          div.style.color = "#fff";
        }

        document.body.appendChild(div);
        setTimeout(() => div.remove(), 700);
      }

      function startGame(playerKey) {
        const pConfig = CHARACTERS[playerKey];
        const bConfig = nnAgent.bot.config; // Use config from training dummy

        p1MaxHealth = p1Health = pConfig.health;
        p2MaxHealth = p2Health = bConfig.health;
        document.getElementById("p1-name-disp").innerText =
          pConfig.name.toUpperCase();
        document.getElementById("p2-name-disp").innerText =
          bConfig.name.toUpperCase();
        updateHealthUI();

        playerSausage = new Sausage(scene, pConfig, -5, false);
        botSausage = new Sausage(scene, bConfig, 5, true);

        // Re-assign entities to the trained agent and enable in-game learning
        nnAgent.bot = botSausage;
        nnAgent.opp = playerSausage;
        nnAgent.isTraining = true;
        nnAgent.epsilon = 0.05; // Start player-mode at low exploration for a challenging bot

        gameActive = true;
      }

      function resolveCollisions() {
        if (!playerSausage || !botSausage) return;
        const p1 = playerSausage,
          p2 = botSausage;
        let hitRegisteredThisFrame = false;

        for (let i = 0; i < p1.points.length; i += 2) {
          for (let j = 0; j < p2.points.length; j += 2) {
            const pt1 = p1.points[i],
              pt2 = p2.points[j];
            const dist = pt1.pos.distanceTo(pt2.pos);
            const minDist = SAUSAGE_RADIUS * 2;

            if (dist < minDist) {
              const dir = pt1.pos.clone().sub(pt2.pos).normalize();
              const overlap = (minDist - dist) * 0.5;
              if (!pt1.pinned) pt1.pos.add(dir.clone().multiplyScalar(overlap));
              if (!pt2.pinned) pt2.pos.sub(dir.clone().multiplyScalar(overlap));

              const v1 = pt1.pos.clone().sub(pt1.oldPos);
              const v2 = pt2.pos.clone().sub(pt2.oldPos);
              const relVel = v1.sub(v2).length();

              // Prevent multiple "WHACKS" in a single physics frame
              if (relVel > 0.4 && !hitRegisteredThisFrame) {
                const dmgBase = relVel * 8;
                // Check for Head Hits
                if (i > p1.points.length - 3) {
                  // We pass raw damage calc, let takeDamage clamp it
                  if (p2.takeDamage(dmgBase * p1.config.damage, pt2.pos)) {
                    hitRegisteredThisFrame = true;
                  }
                }
                if (j > p2.points.length - 3 && !hitRegisteredThisFrame) {
                  if (p1.takeDamage(dmgBase * p2.config.damage, pt1.pos)) {
                    hitRegisteredThisFrame = true;
                  }
                }
              }
            }
          }
        }
      }

      function updateProjectiles() {
        projectiles.forEach((p, index) => {
          if (!p.active) return;
          p.pos.add(p.vel);
          p.mesh.position.copy(p.pos);
          p.mesh.rotation.x += 0.2;
          p.mesh.rotation.z += 0.2;
          p.life--;

          const target = p.ownerIsBot ? playerSausage : botSausage;
          if (target) {
            for (let pt of target.points) {
              if (p.pos.distanceTo(pt.pos) < SAUSAGE_RADIUS + 0.5) {
                target.takeDamage(4, pt.pos);
                if (p.ownerIsBot) nnAgent.recordReward(10);
                p.life = 0;
                break;
              }
            }
          }

          if (p.life <= 0 || p.pos.y < -8) {
            p.active = false;
            scene.remove(p.mesh);
          }
        });
        projectiles = projectiles.filter((p) => p.active);
      }

      function updateInput() {
        if (!playerSausage) return;

        if (joystick.active) {
          playerSausage.targetPos.x += joystick.dx * 0.8;
          playerSausage.targetPos.y += joystick.dy * 0.8;
        } else {
          raycaster.setFromCamera(mouse, camera);
          const target = new THREE.Vector3();
          raycaster.ray.intersectPlane(plane, target);
          playerSausage.targetPos.copy(target);
        }
        playerSausage.targetPos.x = Math.max(
          -WORLD_WIDTH / 2,
          Math.min(WORLD_WIDTH / 2, playerSausage.targetPos.x)
        );
        playerSausage.targetPos.y = Math.max(
          -10,
          Math.min(8, playerSausage.targetPos.y)
        );
      }

      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      function animate() {
        requestAnimationFrame(animate);

        if (gameActive) {
          updateInput();

          // In-game training
          const state = nnAgent.getState();
          // Use brain.js run method for forward propagation (prediction)
          const q_values = Array.from(nnAgent.nn.run(state));

          nnAgent.act(true); // Act using exploitation (low epsilon)
          nnAgent.train(state, q_values, nnAgent.lastAction); // Immediately update Q-value based on actual step reward

          let shouldUpdatePhysics = true;

          // --- SLOW MOTION LOGIC ---
          if (slowMoTimer > 0) {
            slowMoTimer--;
            // Only update physics every 5th frame (simulates time slowing down)
            if (slowMoTimer % 5 !== 0) {
              shouldUpdatePhysics = false;
            }
          }

          if (shouldUpdatePhysics) {
            playerSausage.updatePhysics();
            botSausage.updatePhysics();

            // Run collision resolution multiple times for stability (Verlet integration)
            for (let i = 0; i < ITERATIONS; i++) {
              playerSausage.sticks.forEach((s) => s.update());
              botSausage.sticks.forEach((s) => s.update());
              resolveCollisions();
            }
            updateProjectiles();
          }

          // Visuals always update for camera smoothness (matrix effect)
          playerSausage.updateVisuals();
          botSausage.updateVisuals();
          updateBrainUI();
        }

        camera.position.x += (0 - camera.position.x) * 0.05;
        camera.position.y += (0 - camera.position.y) * 0.05;

        renderer.render(scene, camera);
      }

      animate();

      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (camera.aspect < 1.0) {
          camera.position.z = 40;
          WORLD_WIDTH = 20;
        } else {
          camera.position.z = 24;
          WORLD_WIDTH = 36;
        }
      }
      window.addEventListener("resize", handleResize);
      handleResize();

      // --- BGM Logic ---
      function tryStartBGM() {
        AudioSys.playBGMFromUrl("Pixelated%20Dreams.mp3");
        // tbh idek if this works, this assumes ur browser doesnt block it, but usually default is it does so aksjdbakjsd
      }

      // Try immediately
      tryStartBGM();

      // Bind to all initial interaction types
      window.addEventListener("click", tryStartBGM);
      window.addEventListener("keydown", tryStartBGM);
      window.addEventListener("touchstart", tryStartBGM);

      document.getElementById("bgm-trigger").onclick = () => {
        document.getElementById("bgm-input").click();
      };

      document.getElementById("bgm-input").onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          AudioSys.playBGM(file);
        }
      };

      document.getElementById("bgm-vol").addEventListener("input", (e) => {
          AudioSys.setVolume(e.target.value);
      });
    </script>
  </body>
</html>
