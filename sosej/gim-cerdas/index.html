<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>SOSEJ_DUEL_V3_AI</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Lexend+Mega:wght@700&display=swap");

      :root {
        --bg-color: #ffdcb6;
        --main-accent: #ff5e5e; /* Hot Red */
        --sec-accent: #5e6dff; /* Blue */
        --border-color: #121212;
        --shadow-offset: 6px;
        --border-width: 4px;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #1a1a1a;
        font-family: "Space Mono", monospace;
        cursor: crosshair;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* --- CUSTOM SCROLLBAR (MAXIMUM CHONK) --- */
      /* Firefox */
      * {
        scrollbar-width: thin;
        scrollbar-color: var(--main-accent) #ffffff;
      }

      /* Chrome, Edge, and Safari */
      ::-webkit-scrollbar {
        width: 32px;
        height: 32px;
      }

      ::-webkit-scrollbar-track {
        background: #ffffff;
        border-left: 4px solid var(--border-color);
      }

      ::-webkit-scrollbar-thumb {
        background-color: var(--main-accent);
        border: 6px solid var(--border-color);
        min-height: 50px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background-color: var(--sec-accent);
      }

      /* --- NEO-BRUTALIST UI UTILS --- */
      .nb-box {
        background: #fff;
        border: var(--border-width) solid var(--border-color);
        box-shadow: var(--shadow-offset) var(--shadow-offset) 0px
          var(--border-color);
        padding: 1rem;
        color: var(--border-color);
      }

      .nb-btn {
        background: var(--sec-accent);
        color: white;
        border: var(--border-width) solid var(--border-color);
        box-shadow: var(--shadow-offset) var(--shadow-offset) 0px
          var(--border-color);
        padding: 15px 30px;
        font-family: "Lexend Mega", sans-serif;
        font-size: 1.2rem;
        cursor: pointer;
        text-transform: uppercase;
        transition:
          transform 0.1s,
          box-shadow 0.1s;
      }

      .nb-btn:active:not(:disabled) {
        transform: translate(var(--shadow-offset), var(--shadow-offset));
        box-shadow: 0 0 0 transparent;
      }

      .nb-btn:disabled {
        background: #888;
        color: #ddd;
        cursor: not-allowed;
        opacity: 1;
      }

      /* --- LAYOUTS --- */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* TOP HUD */
      .hud-top {
        display: flex;
        justify-content: space-between;
        padding: 20px;
        gap: 20px;
        width: 100%;
        box-sizing: border-box;
      }

      .health-wrapper {
        width: 45%;
        position: relative;
      }

      .health-track {
        height: 30px;
        background: #fff;
        border: var(--border-width) solid var(--border-color);
        box-shadow: 4px 4px 0px var(--border-color);
        position: relative;
      }

      .health-fill {
        height: 100%;
        width: 100%;
        background: var(--main-accent);
        transition: width 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        border-right: 4px solid black;
      }

      .p-name {
        position: absolute;
        top: -25px;
        font-weight: 900;
        font-size: 14px;
        background: black;
        color: white;
        padding: 2px 8px;
        transform: skewX(-10deg);
      }

      /* BRAIN VISUALIZER (AI DEBUG) */
      #brain-container {
        position: absolute;
        top: 100px;
        right: 20px;
        width: 280px;
        max-height: 60vh;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        pointer-events: auto;
        z-index: 50;
        font-family: "Space Mono", monospace;
        font-size: 10px;
      }

      #brain-toggle {
        background: #000;
        color: #0f0;
        border: 2px solid #0f0;
        padding: 5px 10px;
        cursor: pointer;
        margin-bottom: 5px;
        font-weight: bold;
        box-shadow: 4px 4px 0 #0f0;
        transition: 0.1s;
      }
      #brain-toggle:active {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 #0f0;
      }

      #brain-panel {
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #0f0;
        width: 100%;
        padding: 10px;
        display: none;
        color: #0f0;
        box-shadow: 6px 6px 0 #000;
      }

      .q-row {
        display: flex;
        justify-content: space-between;
        border-bottom: 1px solid #333;
        padding: 4px 0;
      }
      .q-row.active-state {
        background: #004400;
        color: #fff;
        font-weight: bold;
      }
      .q-state {
        width: 40%;
        overflow: hidden;
        white-space: nowrap;
      }
      .q-best-action {
        width: 35%;
        text-align: right;
        color: #ff0;
      }
      .q-val {
        width: 25%;
        text-align: right;
      }

      /* --- SCREENS --- */
      #character-select,
      #training-overlay,
      #end-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100dvh;
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        overflow-y: scroll; /* Forces scrollbar */
        padding: 20px 0;
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }

      #character-select::before,
      #training-overlay::before,
      #end-screen::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 220, 182, 0.95);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: -1;
      }

      h1 {
        font-family: "Lexend Mega", sans-serif;
        font-size: clamp(2.5rem, 6vw, 5rem);
        margin: 20px 0;
        text-transform: uppercase;
        text-shadow: 4px 4px 0px rgba(0, 0, 0, 0.2);
        text-align: center;
        line-height: 0.9;
        flex-shrink: 0;
      }

      .char-grid {
        display: flex;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
        padding: 0 20px;
        max-width: 1000px;
        flex-shrink: 0;
      }

      .char-card {
        width: 150px;
        cursor: pointer;
        transition: transform 0.2s;
        text-align: center;
        flex-shrink: 0;
      }
      .char-card:hover {
        transform: translateY(-5px);
      }
      .char-card.selected {
        background: var(--main-accent);
        color: white;
      }

      .char-icon {
        font-size: 3rem;
        display: block;
        margin-bottom: 5px;
      }
      .char-name {
        font-weight: 700;
        display: block;
        margin-bottom: 5px;
        text-transform: uppercase;
        font-size: 0.9rem;
      }
      .stat-bar {
        background: rgba(0, 0, 0, 0.2);
        height: 6px;
        width: 100%;
        margin: 4px 0;
        position: relative;
      }
      .stat-val-bar {
        height: 100%;
        background: currentColor;
      }

      /* TRAINING TERMINAL */
      #training-overlay {
        background: #000;
        color: #0f0;
        font-family: "Space Mono", monospace;
        justify-content: center;
      }
      #training-overlay::before {
        background: #000;
        backdrop-filter: none;
      }

      .terminal-box {
        border: 2px solid #0f0;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        background: #111;
        box-shadow: 8px 8px 0 #004400;
      }

      /* JOYSTICK */
      #joystick-zone {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        width: 140px;
        height: 140px;
        background: rgba(255, 255, 255, 0.2);
        border: 4px solid rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        z-index: 50;
        pointer-events: auto;
        display: none;
        touch-action: none;
      }

      #joystick-knob {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        background: var(--main-accent);
        border: 4px solid #000;
        border-radius: 50%;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
      }

      .tap-hint {
        position: absolute;
        bottom: 100px;
        width: 100%;
        text-align: center;
        font-weight: bold;
        font-size: 12px;
        opacity: 0.5;
        display: none;
      }

      .dmg-popup {
        position: absolute;
        font-family: "Lexend Mega", sans-serif;
        font-weight: 900;
        color: #fff;
        text-shadow: 3px 3px 0 #000;
        font-size: 24px;
        pointer-events: none;
        animation: popUp 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        z-index: 15;
      }

      @keyframes popUp {
        0% {
          transform: scale(0.5) translateY(0);
          opacity: 0;
        }
        50% {
          transform: scale(1.2) translateY(-20px);
          opacity: 1;
        }
        100% {
          transform: scale(1) translateY(-50px);
          opacity: 0;
        }
      }

      /* START BUTTON (Robust Positioning) */
      #start-btn {
        position: fixed;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999; /* Higher than everything */
        pointer-events: auto;
        box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.5);
      }

      /* --- MOBILE RESPONSIVE TWEAKS --- */
      @media (max-width: 768px) {
        h1 {
          font-size: 2.5rem;
          margin-top: 40px;
        }

        #character-select {
          justify-content: flex-start;
        }

        .hud-top {
          padding: 10px;
        }
        .p-name {
          font-size: 10px;
          top: -18px;
        }
        .health-track {
          height: 20px;
        }

        .char-card {
          width: 42vw;
          margin-bottom: 5px;
        }
        .char-grid {
          gap: 10px;
          padding-bottom: 160px;
        }

        #start-btn {
          bottom: 30px;
          width: 85%;
        }
      }
    </style>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <!-- UI LAYER -->
    <div id="ui-layer">
      <div class="hud-top" id="hud" style="opacity: 0">
        <div class="health-wrapper">
          <div class="p-name" id="p1-name-disp">YOU</div>
          <div
            class="health-track nb-box"
            style="
              padding: 0;
              border: 2px solid black;
              box-shadow: 4px 4px 0 #000;
            "
          >
            <div id="p1-fill" class="health-fill"></div>
          </div>
        </div>
        <div class="health-wrapper">
          <div
            class="p-name"
            id="p2-name-disp"
            style="right: 0; background: var(--sec-accent)"
          >
            AI_BOT
          </div>
          <div
            class="health-track nb-box"
            style="
              padding: 0;
              border: 2px solid black;
              box-shadow: 4px 4px 0 #000;
            "
          >
            <div
              id="p2-fill"
              class="health-fill"
              style="background: var(--sec-accent)"
            ></div>
          </div>
        </div>
      </div>

      <!-- Brain Visualizer -->
      <div id="brain-container">
        <button id="brain-toggle" onclick="toggleBrain()">
          SHOW BOT BRAIN
        </button>
        <div id="brain-panel">
          <div style="margin-bottom: 5px; border-bottom: 1px solid #0f0">
            STATE | BEST ACT | Q-VAL
          </div>
          <div id="q-rows"></div>
        </div>
      </div>

      <div class="tap-hint" id="tap-hint">TAP RIGHT SIDE TO ATTACK</div>

      <div id="joystick-zone">
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- SCREENS -->
    <div id="character-select">
      <h1>SOSEJ</h1>
      <div class="char-grid" id="char-grid"></div>
      <!-- BUTTON IS REMOVED FROM HERE -->
    </div>

    <!-- BUTTON IS NOW HERE: A direct child of BODY -->
    <button id="start-btn" class="nb-btn" disabled>SELECT FIGHTER</button>

    <div id="training-overlay" style="display: none">
      <div class="terminal-box">
        <div style="border-bottom: 1px solid #0f0; margin-bottom: 10px">
          > SYSTEM_BOOT_SEQUENCE
        </div>
        <div id="training-log">> INITIALIZING NEURAL NET...</div>
        <div
          id="loading-bar"
          style="margin-top: 20px; width: 0%; height: 20px; background: #0f0"
        ></div>
      </div>
    </div>

    <div id="end-screen" style="display: none">
      <h1 id="end-title">VICTORY</h1>
      <button id="restart-btn" class="nb-btn">PLAY AGAIN</button>
    </div>

    <script type="module">
      import * as THREE from "three";

      // --- Config & Constants ---
      const GRAVITY = -0.02;
      const FRICTION = 0.96;
      const SEGMENT_LENGTH = 0.55;
      const SAUSAGE_RADIUS = 0.65;
      const ITERATIONS = 40;
      const MAX_DAMAGE = 5;
      const I_FRAMES = 1500;

      // Responsive Bounds
      let WORLD_WIDTH = 36;
      let WORLD_HEIGHT = 20;

      const CHARACTERS = {
        frankfurter: {
          name: "Frank",
          icon: "üå≠",
          color: 0xffaaaa,
          segments: 8,
          weight: 1.0,
          responsiveness: 0.25,
          damage: 1.0,
          health: 100,
        },
        bratwurst: {
          name: "Brat",
          icon: "ü•ñ",
          color: 0xd2691e,
          segments: 12,
          weight: 1.8,
          responsiveness: 0.1,
          damage: 1.5,
          health: 140,
        },
        chorizo: {
          name: "Rizo",
          icon: "üå∂Ô∏è",
          color: 0xff0000,
          segments: 7,
          weight: 0.8,
          responsiveness: 0.35,
          damage: 1.2,
          health: 85,
          trait: "fire",
        },
        boudin: {
          name: "Boudin",
          icon: "‚ö™",
          color: 0xf5f5dc,
          segments: 9,
          weight: 1.1,
          responsiveness: 0.18,
          damage: 1.0,
          health: 110,
          trait: "fire", // Added fire trait for white flame particles
        },
        salami: {
          name: "Salami",
          icon: "üçñ",
          color: 0x8b0000,
          segments: 8,
          weight: 1.2,
          responsiveness: 0.15,
          damage: 0.9,
          health: 120,
          trait: "projectile",
        },
      };

      // --- Game State ---
      let gameActive = false;
      let p1Health = 100,
        p1MaxHealth = 100;
      let p2Health = 100,
        p2MaxHealth = 100;
      let playerSausage, botSausage, qAgent;
      let projectiles = [];
      let isMobile = false;
      let slowMoTimer = 0; // Timer for slow motion effect

      // Input
      const mouse = new THREE.Vector2();
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const raycaster = new THREE.Raycaster();

      // Joystick State
      const joystick = {
        active: false,
        dx: 0,
        dy: 0,
        originX: 0,
        originY: 0,
        currentX: 0,
        currentY: 0,
      };

      // --- Scene Setup ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 0, 24);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // --- Lighting ---
      const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // Floor Grid (Abstract)
      const gridHelper = new THREE.GridHelper(100, 100, 0x333333, 0x111111);
      gridHelper.position.y = -8;
      gridHelper.rotation.x = 0;
      scene.add(gridHelper);

      // --- Joystick Logic ---
      function initJoystick() {
        const zone = document.getElementById("joystick-zone");
        const knob = document.getElementById("joystick-knob");
        const maxDist = 40;

        if ("ontouchstart" in window || navigator.maxTouchPoints) {
          isMobile = true;
          zone.style.display = "block";
          document.getElementById("tap-hint").style.display = "block";
        }

        zone.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = zone.getBoundingClientRect();
            joystick.active = true;
            joystick.originX = rect.left + rect.width / 2;
            joystick.originY = rect.top + rect.height / 2;
            updateKnob(touch.clientX, touch.clientY);
          },
          { passive: false }
        );

        zone.addEventListener(
          "touchmove",
          (e) => {
            e.preventDefault();
            if (joystick.active) {
              const touch = e.changedTouches[0];
              updateKnob(touch.clientX, touch.clientY);
            }
          },
          { passive: false }
        );

        const resetJoystick = (e) => {
          e.preventDefault();
          joystick.active = false;
          joystick.dx = 0;
          joystick.dy = 0;
          knob.style.transform = `translate(-50%, -50%)`;
        };

        zone.addEventListener("touchend", resetJoystick);
        zone.addEventListener("touchcancel", resetJoystick);

        function updateKnob(cx, cy) {
          let dx = cx - joystick.originX;
          let dy = cy - joystick.originY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
          }
          knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
          joystick.dx = dx / maxDist;
          joystick.dy = -dy / maxDist;
        }
      }
      initJoystick();

      // Mobile Attack Tap
      window.addEventListener("touchstart", (e) => {
        if (
          gameActive &&
          playerSausage &&
          e.changedTouches[0].clientX > window.innerWidth / 2
        ) {
          const zone = document
            .getElementById("joystick-zone")
            .getBoundingClientRect();
          const t = e.changedTouches[0];
          if (t.clientX < zone.left || t.clientY < zone.top) {
            playerSausage.shoot();
          }
        }
      });

      // Desktop Shooting Support
      window.addEventListener("mousedown", (e) => {
        if (gameActive && playerSausage) {
          playerSausage.shoot();
        }
      });

      // --- Particle System ---
      function createParticle(pos, color, size) {
        const geo = new THREE.BoxGeometry(size, size, size);
        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);

        // Random offset
        mesh.position.x += (Math.random() - 0.5) * 0.5;
        mesh.position.y += (Math.random() - 0.5) * 0.5;

        scene.add(mesh);

        let life = 20;
        function anim() {
          life--;
          mesh.position.y += 0.08; // Rise up
          mesh.rotation.z += 0.1;
          mesh.scale.multiplyScalar(0.9); // Shrink
          mat.opacity = life / 20;

          if (life > 0) requestAnimationFrame(anim);
          else {
            scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
          }
        }
        anim();
      }

      // --- Physics Engine ---
      class Point {
        constructor(x, y, z) {
          this.pos = new THREE.Vector3(x, y, 0);
          this.oldPos = new THREE.Vector3(x, y, 0);
          this.pinned = false;
        }
        update() {
          if (this.pinned) return;
          const vel = this.pos
            .clone()
            .sub(this.oldPos)
            .multiplyScalar(FRICTION);
          this.oldPos.copy(this.pos);
          this.pos.add(vel);
          this.pos.y += GRAVITY;
          this.pos.z *= 0.1;

          if (this.pos.y < -7) {
            this.pos.y = -7;
            const fX = this.pos.x - this.oldPos.x;
            this.oldPos.x = this.pos.x - fX * 0.5;
          }
        }
      }

      class Stick {
        constructor(p1, p2, length) {
          this.p1 = p1;
          this.p2 = p2;
          this.length = length;
        }
        update() {
          const dx = this.p2.pos.x - this.p1.pos.x;
          const dy = this.p2.pos.y - this.p1.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist === 0) return;
          const diff = this.length - dist;
          const percent = diff / dist / 2;
          const offsetX = dx * percent;
          const offsetY = dy * percent;
          if (!this.p1.pinned) {
            this.p1.pos.x -= offsetX;
            this.p1.pos.y -= offsetY;
          }
          if (!this.p2.pinned) {
            this.p2.pos.x += offsetX;
            this.p2.pos.y += offsetY;
          }
        }
      }

      // --- Entities ---
      class Sausage {
        constructor(scene, config, startX, isBot = false) {
          this.points = [];
          this.sticks = [];
          this.scene = scene;
          this.isBot = isBot;
          this.config = config;
          this.targetPos = new THREE.Vector3(startX, -4, 0);
          this.lastHitTime = 0;
          this.cooldown = 0;

          for (let i = 0; i < config.segments; i++) {
            this.points.push(new Point(startX, -4 + i * SEGMENT_LENGTH, 0));
          }
          for (let i = 0; i < this.points.length - 1; i++) {
            this.sticks.push(
              new Stick(this.points[i], this.points[i + 1], SEGMENT_LENGTH)
            );
          }
          for (let i = 0; i < this.points.length - 2; i++) {
            this.sticks.push(
              new Stick(this.points[i], this.points[i + 2], SEGMENT_LENGTH * 2)
            );
          }
          const handleLen = Math.floor(config.segments * 0.4);
          for (let i = 0; i < handleLen; i++) {
            for (let j = i + 1; j < handleLen; j++) {
              const dist = Math.abs(j - i) * SEGMENT_LENGTH;
              this.sticks.push(new Stick(this.points[i], this.points[j], dist));
            }
          }
          const base = this.points[0];
          this.sticks.push(
            new Stick(
              base,
              this.points[Math.floor(config.segments * 0.6)],
              SEGMENT_LENGTH * Math.floor(config.segments * 0.6)
            )
          );
          this.sticks.push(
            new Stick(
              base,
              this.points[Math.floor(config.segments * 0.8)],
              SEGMENT_LENGTH * Math.floor(config.segments * 0.8)
            )
          );

          const curve = new THREE.CatmullRomCurve3(
            this.points.map((p) => p.pos)
          );
          this.geometry = new THREE.TubeGeometry(
            curve,
            config.segments * 4,
            SAUSAGE_RADIUS,
            8,
            false
          );
          this.material = new THREE.MeshToonMaterial({
            color: config.color,
            emissive: 0x000000,
          });
          this.mesh = new THREE.Mesh(this.geometry, this.material);
          this.mesh.castShadow = true;
          scene.add(this.mesh);

          this.headMesh = new THREE.Mesh(
            new THREE.SphereGeometry(SAUSAGE_RADIUS * 1.0, 16, 16),
            new THREE.MeshToonMaterial({ color: isBot ? 0x222222 : 0xffffff })
          );
          this.headMesh.castShadow = true;
          this.buttMesh = new THREE.Mesh(
            new THREE.SphereGeometry(SAUSAGE_RADIUS * 0.98, 16, 16),
            this.material
          );
          scene.add(this.headMesh);
          scene.add(this.buttMesh);
        }

        getHeadPos() {
          return this.points[this.points.length - 1].pos;
        }

        shoot() {
          if (this.config.trait !== "projectile" || this.cooldown > 0) return;
          const head = this.getHeadPos();
          const neck = this.points[this.points.length - 2].pos;
          const dir = head.clone().sub(neck).normalize().multiplyScalar(0.9);
          projectiles.push({
            pos: head.clone(),
            vel: dir,
            mesh: new THREE.Mesh(
              new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8),
              new THREE.MeshBasicMaterial({ color: 0xff0000 })
            ),
            active: true,
            ownerIsBot: this.isBot,
            life: 100,
          });
          scene.add(projectiles[projectiles.length - 1].mesh);
          this.cooldown = 60;
        }

        takeDamage(amount, hitPos = null) {
          // I-FRAMES CHECK (GLOBAL TIMESTAMP CHECK)
          if (Date.now() - this.lastHitTime < I_FRAMES) return false;

          this.lastHitTime = Date.now();

          // --- HARD CLAMP DAMAGE ---
          let actualDamage = Math.min(amount, MAX_DAMAGE);

          // --- TRIGGER SLOW MO ---
          slowMoTimer = 45; // ~0.75 seconds of slow mo

          // Visual Hit Feedback (Blink White)
          this.material.emissive.setHex(0xffffff);

          // Blink effect for I-Frames
          let blinkCount = 0;
          const blinkInterval = setInterval(() => {
            blinkCount++;
            if (blinkCount % 2 === 0) this.material.emissive.setHex(0x000000);
            else this.material.emissive.setHex(0x444444); // Dim gray

            if (Date.now() - this.lastHitTime >= I_FRAMES) {
              clearInterval(blinkInterval);
              this.material.emissive.setHex(0x000000);
            }
          }, 100);

          if (this.isBot) {
            p2Health -= actualDamage;
            if (qAgent) qAgent.recordReward(-20);
          } else {
            p1Health -= actualDamage;
            if (qAgent) qAgent.recordReward(40);
          }

          // Camera Shake
          const shake = Math.min(actualDamage * 0.2, 1.5);
          camera.position.x += (Math.random() - 0.5) * shake;
          camera.position.y += (Math.random() - 0.5) * shake;

          updateHealthUI();

          if (hitPos) showDamage(actualDamage, hitPos);
          return true;
        }

        updatePhysics() {
          if (this.cooldown > 0) this.cooldown--;

          const base = this.points[0];
          const lerpFactor = this.isBot ? 0.08 : this.config.responsiveness;

          base.pos.lerp(this.targetPos, lerpFactor);
          base.pos.z = 0;
          base.pinned = true;

          this.points.forEach((p) => p.update());
          for (let k = 0; k < 2; k++) this.sticks.forEach((s) => s.update());

          // Particle Emitter Logic
          if (this.config.trait === "fire") {
            if (Math.random() < 0.3) {
              createParticle(this.getHeadPos(), this.config.color, 0.5);
            }
          }
        }

        updateVisuals() {
          this.mesh.geometry.dispose();
          const curve = new THREE.CatmullRomCurve3(
            this.points.map((p) => p.pos)
          );
          this.mesh.geometry = new THREE.TubeGeometry(
            curve,
            this.config.segments * 4,
            SAUSAGE_RADIUS,
            12,
            false
          );
          this.headMesh.position.copy(this.points[this.points.length - 1].pos);
          this.buttMesh.position.copy(this.points[0].pos);
        }
      }

      // --- ENHANCED Q-LEARNING AI ---
      const ACTION_NAMES = [
        "CHARGE",
        "RETREAT",
        "HIGH GUARD",
        "LOW CUT",
        "CENTER",
      ];

      class QAgent {
        constructor(bot, opp) {
          this.bot = bot;
          this.opp = opp;
          this.qTable = {};
          this.learningRate = 0.1;
          this.discountFactor = 0.9;
          this.epsilon = 0.1;
          this.age = 0;

          this.lastState = null;
          this.lastAction = null;
          this.currentReward = 0;
          this.isTraining = true;
          // Actions: Advance, Retreat, Up-Attack, Down-Attack, Center
          this.actions = [
            { x: -2, y: -4 },
            { x: 15, y: -4 },
            { x: 8, y: 4 },
            { x: 8, y: -8 },
            { x: 5, y: -4 },
          ];
        }

        getState() {
          const b = this.bot.getHeadPos(),
            p = this.opp.getHeadPos();
          const dx = p.x - b.x,
            dy = p.y - b.y,
            dist = Math.sqrt(dx * dx + dy * dy);

          let xStr = "ALIGNED";
          if (dx < -2) xStr = "LEFT";
          else if (dx > 2) xStr = "RIGHT";
          let yStr = "LEVEL";
          if (dy < -2) yStr = "BELOW";
          else if (dy > 2) yStr = "ABOVE";
          let dStr = "MID";
          if (dist < 6) dStr = "CLOSE";
          else if (dist > 12) dStr = "FAR";

          return `${xStr}_${yStr}_${dStr}`;
        }

        act() {
          // DYNAMIC EPSILON: Oscillate between 0.05 (Smart) and 0.40 (Crazy)
          if (this.isTraining) {
            this.age++;
            const wave = (Math.sin(this.age * 0.01) + 1) / 2;
            this.epsilon = 0.05 + wave * 0.35;
          }

          const state = this.getState();
          let actionIdx;

          if (!this.qTable[state]) this.qTable[state] = [0, 0, 0, 0, 0];

          if (this.isTraining && Math.random() < this.epsilon) {
            actionIdx = Math.floor(Math.random() * this.actions.length);
          } else {
            const vals = this.qTable[state];
            // Add noise to break ties randomly
            const noisyVals = vals.map((v) => v + Math.random() * 0.01);
            actionIdx = noisyVals.indexOf(Math.max(...noisyVals));
          }

          const act = this.actions[actionIdx];
          const pBase = this.opp.points[0].pos;
          this.bot.targetPos.x = THREE.MathUtils.lerp(
            this.bot.targetPos.x,
            pBase.x + act.x,
            0.12
          );
          this.bot.targetPos.y = THREE.MathUtils.lerp(
            this.bot.targetPos.y,
            act.y,
            0.12
          );

          if (this.isTraining && this.lastState) {
            const oldQ = this.qTable[this.lastState][this.lastAction];
            const maxNextQ = Math.max(...this.qTable[state]);
            const newQ =
              oldQ +
              this.learningRate *
                (this.currentReward + this.discountFactor * maxNextQ - oldQ);
            this.qTable[this.lastState][this.lastAction] = newQ;
          }

          this.lastState = state;
          this.lastAction = actionIdx;
          this.currentReward = -0.2; // Living cost to encourage action
        }

        recordReward(r) {
          this.currentReward += r;
        }
      }

      // --- FSM Teacher for Training ---
      const FSM = {
        t: 0,
        s: "IDLE",
        update: function (bot, opp) {
          this.t++;
          if (this.t > 40) {
            this.t = 0;
            const r = Math.random();
            this.s = r < 0.5 ? "IDLE" : r < 0.8 ? "ATK" : "DEF";
          }
          let tx = 8,
            ty = -4;
          const pBase = opp.points[0].pos;
          if (this.s === "ATK") {
            tx = 0;
            ty = -2;
          } else if (this.s === "DEF") {
            tx = 10;
            ty = 2;
          }
          bot.targetPos.x = THREE.MathUtils.lerp(
            bot.targetPos.x,
            pBase.x + tx,
            0.1
          );
          bot.targetPos.y = THREE.MathUtils.lerp(bot.targetPos.y, ty, 0.1);
        },
      };

      // --- UI Logic ---
      const charGrid = document.getElementById("char-grid");
      const startBtn = document.getElementById("start-btn");
      let selectedCharKey = null;

      Object.entries(CHARACTERS).forEach(([key, data]) => {
        const card = document.createElement("div");
        card.className = "char-card nb-box";
        card.innerHTML = `
                <span class="char-icon">${data.icon}</span>
                <span class="char-name">${data.name}</span>
                <div class="stat-bar"><div class="stat-val-bar" style="width:${data.responsiveness * 250}%; color:#5e6dff"></div></div>
                <div class="stat-bar"><div class="stat-val-bar" style="width:${data.damage * 60}%; color:#ff5e5e"></div></div>
            `;
        card.onclick = () => {
          document
            .querySelectorAll(".char-card")
            .forEach((c) => c.classList.remove("selected"));
          card.classList.add("selected");
          selectedCharKey = key;
          startBtn.disabled = false;
          // IMPORTANT: Update button style to show it's ready
          startBtn.style.background = "#ff5e5e";
          startBtn.style.color = "white";
          startBtn.innerText = "INITIATE SEQUENCE";
        };
        charGrid.appendChild(card);
      });

      // Brain Visualizer Logic
      window.toggleBrain = () => {
        const p = document.getElementById("brain-panel");
        p.style.display = p.style.display === "none" ? "block" : "none";
      };

      function updateBrainUI() {
        const panel = document.getElementById("q-rows");
        if (
          document.getElementById("brain-panel").style.display === "none" ||
          !qAgent
        )
          return;

        let html = "";
        const curState = qAgent.getState();
        const keys = Object.keys(qAgent.qTable);

        // Show current Epsilon
        const epsColor =
          qAgent.epsilon > 0.3
            ? "#f0f"
            : qAgent.epsilon < 0.1
              ? "#0ff"
              : "#fff";
        html += `<div style="border-bottom:1px solid #555; padding:5px; color:${epsColor}; text-align:center;">
                EPSILON: ${qAgent.epsilon.toFixed(2)} (${qAgent.epsilon > 0.25 ? "CHAOS" : "FOCUS"})
            </div>`;

        const fmt = (s) =>
          s
            .replace("LEFT", "‚¨ÖÔ∏è")
            .replace("RIGHT", "‚û°Ô∏è")
            .replace("ALIGNED", "‚è∫Ô∏è")
            .replace("ABOVE", "‚¨ÜÔ∏è")
            .replace("BELOW", "‚¨áÔ∏è")
            .replace("LEVEL", "‚è∫Ô∏è")
            .replace("CLOSE", "‚öîÔ∏è")
            .replace("MID", "üìè")
            .replace("FAR", "üî≠");

        // Show active state first
        if (qAgent.qTable[curState]) {
          const vals = qAgent.qTable[curState];
          const bestIdx = vals.indexOf(Math.max(...vals));
          html += `<div class="q-row active-state">
                    <div class="q-state">CUR: ${fmt(curState)}</div>
                    <div class="q-best-action">${ACTION_NAMES[bestIdx]}</div>
                    <div class="q-val">${vals[bestIdx].toFixed(1)}</div>
                </div>`;
        }

        // Show few others
        keys.slice(0, 5).forEach((k) => {
          if (k === curState) return;
          const vals = qAgent.qTable[k];
          const bestIdx = vals.indexOf(Math.max(...vals));
          html += `<div class="q-row">
                    <div class="q-state">${fmt(k)}</div>
                    <div class="q-best-action">${ACTION_NAMES[bestIdx]}</div>
                    <div class="q-val">${vals[bestIdx].toFixed(1)}</div>
                </div>`;
        });
        panel.innerHTML = html;
      }

      startBtn.onclick = async () => {
        document.getElementById("character-select").style.display = "none";
        // Button is outside now, so manually hide it
        startBtn.style.display = "none";

        document.getElementById("training-overlay").style.display = "flex";

        await bootstrap(selectedCharKey);

        document.getElementById("training-overlay").style.display = "none";
        document.getElementById("hud").style.opacity = 1;
        startGame(selectedCharKey);
      };

      document.getElementById("restart-btn").onclick = () => {
        location.reload();
      };

      // --- Training (Bootstrapping) ---
      async function bootstrap(playerKey) {
        const log = document.getElementById("training-log");
        const keys = Object.keys(CHARACTERS);
        const botC = CHARACTERS[keys[Math.floor(Math.random() * keys.length)]];
        const pC = CHARACTERS[playerKey];

        // Temporary Sim Entities
        const tp = new Sausage(scene, pC, -5, false);
        const tb = new Sausage(scene, botC, 5, true);
        const agent = new QAgent(tb, tp);

        // Hide them during training (or move them far away)
        tp.mesh.position.y = -1000;
        tb.mesh.position.y = -1000;

        const TRAIN_FRAMES = 3000;
        const bar = document.getElementById("loading-bar");

        return new Promise((r) => {
          let f = 0;
          function step() {
            for (let k = 0; k < 50; k++) {
              // Fast forward
              if (f++ > TRAIN_FRAMES) break;
              FSM.update(tp, tb);
              agent.act();
              tp.updatePhysics();
              tb.updatePhysics();

              // Simple Training Collision Logic (Approximation)
              const h1 = tp.getHeadPos(),
                h2 = tb.getHeadPos();
              if (h1.distanceTo(h2) < 2.5) {
                const v1 = tp.points[0].pos.distanceTo(tp.points[0].oldPos);
                const v2 = tb.points[0].pos.distanceTo(tb.points[0].oldPos);
                // Reward if bot moving faster than player at impact
                agent.recordReward(v2 > v1 ? 20 : -10);
              }
            }

            const pct = Math.round((f / TRAIN_FRAMES) * 100);
            bar.style.width = pct + "%";
            if (f % 300 === 0)
              log.innerHTML = `> TRAINING NEURAL NET... [${pct}%]`;

            if (f <= TRAIN_FRAMES) requestAnimationFrame(step);
            else {
              scene.remove(tp.mesh);
              scene.remove(tp.headMesh);
              scene.remove(tp.buttMesh);
              scene.remove(tb.mesh);
              scene.remove(tb.headMesh);
              scene.remove(tb.buttMesh);
              qAgent = agent; // Transfer learned agent
              r();
            }
          }
          step();
        });
      }

      // --- Game Functions ---
      function updateHealthUI() {
        const p1Pct = Math.max(0, (p1Health / p1MaxHealth) * 100);
        const p2Pct = Math.max(0, (p2Health / p2MaxHealth) * 100);
        document.getElementById("p1-fill").style.width = p1Pct + "%";
        document.getElementById("p2-fill").style.width = p2Pct + "%";
        if ((p1Health <= 0 || p2Health <= 0) && gameActive) endGame();
      }

      function endGame() {
        gameActive = false;
        document.getElementById("end-screen").style.display = "flex";
        document.getElementById("end-title").innerText =
          p1Health > 0 ? "VICTORY" : "FATAL ERROR";
        document.getElementById("end-title").style.color =
          p1Health > 0 ? "#0f0" : "#f00";
      }

      function showDamage(amount, pos) {
        const div = document.createElement("div");
        div.className = "dmg-popup";
        div.innerText = Math.round(amount);

        const tempV = pos.clone();
        tempV.project(camera);
        div.style.left = (tempV.x * 0.5 + 0.5) * window.innerWidth + "px";
        div.style.top = (-(tempV.y * 0.5) + 0.5) * window.innerHeight + "px";

        if (amount >= MAX_DAMAGE - 0.5) {
          div.innerText = "CRIT!";
          div.style.color = "#ff0055";
        } else {
          div.style.color = "#fff";
        }

        document.body.appendChild(div);
        setTimeout(() => div.remove(), 700);
      }

      function startGame(playerKey) {
        const pConfig = CHARACTERS[playerKey];
        const bConfig = qAgent.bot.config; // Use config from training dummy

        p1MaxHealth = p1Health = pConfig.health;
        p2MaxHealth = p2Health = bConfig.health;
        document.getElementById("p1-name-disp").innerText =
          pConfig.name.toUpperCase();
        document.getElementById("p2-name-disp").innerText =
          bConfig.name.toUpperCase();
        updateHealthUI();

        playerSausage = new Sausage(scene, pConfig, -5, false);
        botSausage = new Sausage(scene, bConfig, 5, true);

        // Re-assign entities to the trained agent
        qAgent.bot = botSausage;
        qAgent.opp = playerSausage;
        qAgent.isTraining = true; // Keep learning!

        gameActive = true;
      }

      function resolveCollisions() {
        if (!playerSausage || !botSausage) return;
        const p1 = playerSausage,
          p2 = botSausage;
        let hitRegisteredThisFrame = false;

        for (let i = 0; i < p1.points.length; i += 2) {
          for (let j = 0; j < p2.points.length; j += 2) {
            const pt1 = p1.points[i],
              pt2 = p2.points[j];
            const dist = pt1.pos.distanceTo(pt2.pos);
            const minDist = SAUSAGE_RADIUS * 2;

            if (dist < minDist) {
              const dir = pt1.pos.clone().sub(pt2.pos).normalize();
              const overlap = (minDist - dist) * 0.5;
              if (!pt1.pinned) pt1.pos.add(dir.clone().multiplyScalar(overlap));
              if (!pt2.pinned) pt2.pos.sub(dir.clone().multiplyScalar(overlap));

              const v1 = pt1.pos.clone().sub(pt1.oldPos);
              const v2 = pt2.pos.clone().sub(pt2.oldPos);
              const relVel = v1.sub(v2).length();

              // Prevent multiple "WHACKS" in a single physics frame
              if (relVel > 0.4 && !hitRegisteredThisFrame) {
                const dmgBase = relVel * 8;
                // Check for Head Hits
                if (i > p1.points.length - 3) {
                  // We pass raw damage calc, let takeDamage clamp it
                  if (p2.takeDamage(dmgBase * p1.config.damage, pt2.pos)) {
                    hitRegisteredThisFrame = true;
                  }
                }
                if (j > p2.points.length - 3 && !hitRegisteredThisFrame) {
                  if (p1.takeDamage(dmgBase * p2.config.damage, pt1.pos)) {
                    hitRegisteredThisFrame = true;
                  }
                }
              }
            }
          }
        }
      }

      function updateProjectiles() {
        projectiles.forEach((p, index) => {
          if (!p.active) return;
          p.pos.add(p.vel);
          p.mesh.position.copy(p.pos);
          p.mesh.rotation.x += 0.2;
          p.mesh.rotation.z += 0.2;
          p.life--;

          const target = p.ownerIsBot ? playerSausage : botSausage;
          if (target) {
            for (let pt of target.points) {
              if (p.pos.distanceTo(pt.pos) < SAUSAGE_RADIUS + 0.5) {
                target.takeDamage(4, pt.pos);
                if (p.ownerIsBot) qAgent.recordReward(10);
                p.life = 0;
                break;
              }
            }
          }

          if (p.life <= 0 || p.pos.y < -8) {
            p.active = false;
            scene.remove(p.mesh);
          }
        });
        projectiles = projectiles.filter((p) => p.active);
      }

      function updateInput() {
        if (joystick.active) {
          const rangeX = 14;
          playerSausage.targetPos.x += joystick.dx * 0.8;
          playerSausage.targetPos.y += joystick.dy * 0.8;
        } else {
          raycaster.setFromCamera(mouse, camera);
          const target = new THREE.Vector3();
          raycaster.ray.intersectPlane(plane, target);
          playerSausage.targetPos.copy(target);
        }
        playerSausage.targetPos.x = Math.max(
          -WORLD_WIDTH / 2,
          Math.min(WORLD_WIDTH / 2, playerSausage.targetPos.x)
        );
        playerSausage.targetPos.y = Math.max(
          -10,
          Math.min(8, playerSausage.targetPos.y)
        );
      }

      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      function animate() {
        requestAnimationFrame(animate);

        if (gameActive) {
          updateInput();
          qAgent.act();

          let shouldUpdatePhysics = true;

          // --- SLOW MOTION LOGIC ---
          if (slowMoTimer > 0) {
            slowMoTimer--;
            // Only update physics every 5th frame (simulates time slowing down)
            if (slowMoTimer % 5 !== 0) {
              shouldUpdatePhysics = false;
            }
          }

          if (shouldUpdatePhysics) {
            playerSausage.updatePhysics();
            botSausage.updatePhysics();

            for (let i = 0; i < ITERATIONS; i++) {
              playerSausage.sticks.forEach((s) => s.update());
              botSausage.sticks.forEach((s) => s.update());
              resolveCollisions();
            }
            updateProjectiles();
          }

          // Visuals always update for camera smoothness (matrix effect)
          playerSausage.updateVisuals();
          botSausage.updateVisuals();
          updateBrainUI();
        }

        camera.position.x += (0 - camera.position.x) * 0.05;
        camera.position.y += (0 - camera.position.y) * 0.05;

        renderer.render(scene, camera);
      }

      animate();

      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (camera.aspect < 1.0) {
          camera.position.z = 40;
          WORLD_WIDTH = 20;
        } else {
          camera.position.z = 24;
          WORLD_WIDTH = 36;
        }
      }
      window.addEventListener("resize", handleResize);
      handleResize();
    </script>
  </body>
</html>
