<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sosej</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@400;600;700&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: "Poppins", sans-serif;
        overflow: hidden;
      }

      #gameContainer {
        position: relative;
        transition: transform 0.05s;
      }

      #gameContainer.shake {
        animation: shake 0.5s;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translate(0, 0);
        }
        10% {
          transform: translate(-12px, 5px);
        }
        20% {
          transform: translate(12px, -5px);
        }
        30% {
          transform: translate(-10px, -5px);
        }
        40% {
          transform: translate(10px, 5px);
        }
        50% {
          transform: translate(-12px, -5px);
        }
        60% {
          transform: translate(12px, 5px);
        }
        70% {
          transform: translate(-10px, 5px);
        }
        80% {
          transform: translate(10px, -5px);
        }
        90% {
          transform: translate(-6px, 4px);
        }
      }

      canvas {
        border: 6px solid #fff;
        border-radius: 15px;
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
        background: #87ceeb;
        cursor: none;
        display: none;
      }

      canvas.active {
        display: block;
      }

      /* Character Selection Screen */
      #characterSelect {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        max-width: 1000px;
        width: 90vw;
      }

      #characterSelect.hidden {
        display: none;
      }

      #characterSelect h1 {
        font-family: "Bangers", cursive;
        font-size: 72px;
        color: #764ba2;
        margin-bottom: 10px;
        text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.1);
        letter-spacing: 2px;
      }

      #characterSelect .subtitle {
        font-size: 18px;
        color: #666;
        margin-bottom: 30px;
      }

      .characterGrid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 20px;
        margin-bottom: 30px;
      }

      @media (max-width: 1000px) {
        .characterGrid {
          grid-template-columns: repeat(3, 1fr);
        }
      }

      @media (max-width: 600px) {
        .characterGrid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .characterCard {
        background: white;
        border: 4px solid #ddd;
        border-radius: 15px;
        padding: 20px 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        min-height: 200px;
        display: flex;
        flex-direction: column;
      }

      .characterCard:hover {
        transform: translateY(-5px);
        border-color: #667eea;
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
      }

      .characterCard.selected {
        border-color: #667eea;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        transform: scale(1.05);
      }

      .characterCard .icon {
        font-size: 48px;
        margin-bottom: 10px;
      }

      .characterCard .name {
        font-weight: 700;
        font-size: 16px;
        margin-bottom: 5px;
      }

      .characterCard .type {
        font-size: 11px;
        color: #888;
        margin-bottom: 15px;
        min-height: 30px;
      }

      .characterCard.selected .type {
        color: rgba(255, 255, 255, 0.9);
      }

      .characterCard .stats {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 10px;
        text-align: left;
        margin-top: auto;
      }

      .stat {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .stat span {
        white-space: nowrap;
        min-width: 50px;
      }

      .statBar {
        flex: 1;
        height: 6px;
        background: #ddd;
        border-radius: 3px;
        overflow: hidden;
      }

      .statBarFill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        border-radius: 3px;
      }

      .characterCard.selected .statBar {
        background: rgba(255, 255, 255, 0.3);
      }

      .characterCard.selected .statBarFill {
        background: linear-gradient(90deg, #fff, #f0f0f0);
      }

      #startButton {
        padding: 20px 60px;
        font-size: 24px;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        font-family: "Bangers", cursive;
        letter-spacing: 1px;
      }

      #startButton:hover:not(:disabled) {
        transform: scale(1.05);
        box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
      }

      #startButton:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* In-Game UI */
      #ui {
        position: absolute;
        top: 20px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        padding: 0 30px;
        pointer-events: none;
      }

      .playerInfo {
        background: rgba(255, 255, 255, 0.95);
        padding: 20px 25px;
        border-radius: 15px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        min-width: 280px;
        border: 3px solid #fff;
      }

      .playerHeader {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }

      .playerIcon {
        font-size: 32px;
      }

      .playerDetails {
        flex: 1;
      }

      .playerName {
        font-weight: 700;
        font-size: 20px;
        color: #333;
        font-family: "Bangers", cursive;
        letter-spacing: 1px;
      }

      .playerType {
        font-size: 12px;
        color: #666;
      }

      .healthBarContainer {
        width: 100%;
        height: 30px;
        background: #e0e0e0;
        border-radius: 15px;
        overflow: hidden;
        border: 3px solid #333;
        position: relative;
      }

      .healthBar {
        height: 100%;
        transition: width 0.3s ease;
        border-radius: 15px;
        background: linear-gradient(90deg, #ff6b6b, #ee5a6f);
        position: relative;
        overflow: hidden;
      }

      .healthBar::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.3) 50%,
          transparent 100%
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .player2Health {
        background: linear-gradient(90deg, #4ecdc4, #44a08d);
      }

      .healthText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: 700;
        font-size: 14px;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        z-index: 1;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.98);
        padding: 50px 80px;
        border-radius: 25px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        display: none;
        border: 5px solid #667eea;
      }

      #gameOver h1 {
        font-family: "Bangers", cursive;
        font-size: 64px;
        margin-bottom: 20px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      #gameOver .winner {
        font-size: 24px;
        color: #666;
        margin-bottom: 30px;
      }

      #gameOver button {
        padding: 18px 50px;
        font-size: 22px;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        pointer-events: all;
        transition: all 0.3s ease;
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        font-family: "Bangers", cursive;
        letter-spacing: 1px;
      }

      #gameOver button:hover {
        transform: scale(1.05);
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 30px;
        border-radius: 50px;
        text-align: center;
        font-size: 14px;
        color: #333;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        border: 2px solid #fff;
      }

      .cursor {
        position: absolute;
        width: 24px;
        height: 24px;
        border: 4px solid #fff;
        border-radius: 50%;
        background: rgba(102, 126, 234, 0.4);
        pointer-events: none;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
        z-index: 10000;
      }

      .damageText {
        position: absolute;
        color: #ff4444;
        font-weight: 900;
        font-size: 32px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        pointer-events: none;
        animation: floatUp 1s ease-out forwards;
        font-family: "Bangers", cursive;
      }

      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateY(-60px) scale(1.2);
        }
      }

      .particle {
        position: absolute;
        pointer-events: none;
        border-radius: 50%;
      }

      .impactRing {
        position: absolute;
        border: 4px solid rgba(255, 255, 0, 0.8);
        border-radius: 50%;
        pointer-events: none;
        animation: impactExpand 0.5s ease-out forwards;
      }

      @keyframes impactExpand {
        0% {
          width: 30px;
          height: 30px;
          opacity: 1;
        }
        100% {
          width: 120px;
          height: 120px;
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="cursor" id="cursor"></div>

    <!-- Character Selection Screen -->
    <div id="characterSelect">
      <h1>🌭 SOSEJ 🌭</h1>
      <p class="subtitle">Choose Your Fighter!</p>

      <div class="characterGrid">
        <div class="characterCard" data-character="frankfurter">
          <div class="icon">🌭</div>
          <div class="name">Frankfurter</div>
          <div class="type">Quick Jabs</div>
          <div class="stats">
            <div class="stat">
              <span>Speed:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 90%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Power:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 60%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Stiffness:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 50%"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="characterCard" data-character="bratwurst">
          <div class="icon">🥖</div>
          <div class="name">Bratwurst</div>
          <div class="type">Heavy Hitter</div>
          <div class="stats">
            <div class="stat">
              <span>Speed:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 40%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Power:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 100%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Stiffness:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 90%"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="characterCard" data-character="chorizo">
          <div class="icon">🌶️</div>
          <div class="name">Chorizo</div>
          <div class="type">Flame Attacks</div>
          <div class="stats">
            <div class="stat">
              <span>Speed:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 95%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Power:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 70%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Stiffness:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 30%"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="characterCard" data-character="boudin">
          <div class="icon">⚪</div>
          <div class="name">Boudin Blanc</div>
          <div class="type">Graceful Sweeps</div>
          <div class="stats">
            <div class="stat">
              <span>Speed:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 75%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Power:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 75%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Stiffness:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 60%"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="characterCard" data-character="salami">
          <div class="icon">🔴</div>
          <div class="name">Salami</div>
          <div class="type">Projectile Master</div>
          <div class="stats">
            <div class="stat">
              <span>Speed:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 70%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Power:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 65%"></div>
              </div>
            </div>
            <div class="stat">
              <span>Stiffness:</span>
              <div class="statBar">
                <div class="statBarFill" style="width: 70%"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <button id="startButton" disabled>SELECT A CHARACTER</button>
    </div>

    <div id="gameContainer">
      <canvas id="gameCanvas" width="1200" height="700"></canvas>

      <div id="ui">
        <div class="playerInfo">
          <div class="playerHeader">
            <div class="playerIcon" id="player1Icon">🌭</div>
            <div class="playerDetails">
              <div class="playerName" id="player1Name">Player</div>
              <div class="playerType" id="player1Type">Frankfurter</div>
            </div>
          </div>
          <div class="healthBarContainer">
            <div class="healthText" id="player1HealthText">100 / 100</div>
            <div
              class="healthBar player1Health"
              id="player1Health"
              style="width: 100%"
            ></div>
          </div>
        </div>
        <div class="playerInfo">
          <div class="playerHeader">
            <div class="playerIcon" id="player2Icon">🤖</div>
            <div class="playerDetails">
              <div class="playerName" id="player2Name">Bot</div>
              <div class="playerType" id="player2Type">Random</div>
            </div>
          </div>
          <div class="healthBarContainer">
            <div class="healthText" id="player2HealthText">100 / 100</div>
            <div
              class="healthBar player2Health"
              id="player2Health"
              style="width: 100%"
            ></div>
          </div>
        </div>
      </div>

      <div id="gameOver">
        <h1 id="winnerText">VICTORY!</h1>
        <p class="winner" id="winnerSubtext">Player Wins!</p>
        <button onclick="backToMenu()">Back to Menu</button>
      </div>

      <div id="controls">
        <strong
          >🖱️ Move your mouse to flop your sosej! • Click to shoot
          (Salami)</strong
        >
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const cursorElement = document.getElementById("cursor");
      const gameContainer = document.getElementById("gameContainer");
      const characterSelect = document.getElementById("characterSelect");

      // Character definitions with stiffness
      const CHARACTERS = {
        frankfurter: {
          name: "Frankfurter",
          icon: "🌭",
          color: "#D2691E",
          weight: 0.3,
          responsiveness: 0.25,
          damage: 0.8,
          health: 100,
          segments: 8,
          segmentWeight: 0.95,
          stiffness: 0.5,
          description: "Quick Jabs",
        },
        bratwurst: {
          name: "Bratwurst",
          icon: "🥖",
          color: "#8B6914",
          weight: 1.0,
          responsiveness: 0.08,
          damage: 1.8,
          health: 140,
          segments: 10,
          segmentWeight: 1.5,
          stiffness: 0.9,
          description: "Heavy Hitter",
        },
        chorizo: {
          name: "Chorizo",
          icon: "🌶️",
          color: "#DC143C",
          weight: 0.25,
          responsiveness: 0.3,
          damage: 1.0,
          health: 85,
          segments: 7,
          segmentWeight: 0.8,
          stiffness: 0.3,
          description: "Flame Attacks",
          hasFlames: true,
        },
        boudin: {
          name: "Boudin Blanc",
          icon: "⚪",
          color: "#F5F5DC",
          weight: 0.5,
          responsiveness: 0.18,
          damage: 1.0,
          health: 100,
          segments: 9,
          segmentWeight: 1.0,
          stiffness: 0.6,
          description: "Graceful Sweeps",
          elegant: true,
        },
        salami: {
          name: "Salami",
          icon: "🔴",
          color: "#8B0000",
          weight: 0.6,
          responsiveness: 0.15,
          damage: 0.9,
          health: 110,
          segments: 8,
          segmentWeight: 1.1,
          stiffness: 0.7,
          description: "Projectile Master",
          hasProjectiles: true,
        },
      };

      let selectedCharacter = null;
      let player1Character = null;
      let player2Character = null;
      let gameRunning = false;
      let mouseX = canvas.width / 4;
      let mouseY = canvas.height / 2;
      let projectiles = [];

      // Time manipulation - EVEN LONGER SLOW-MO!
      let timeScale = 1.0;
      let freezeFrameTimer = 0;
      let slowMoTimer = 0;

      // Character selection
      document.querySelectorAll(".characterCard").forEach((card) => {
        card.addEventListener("click", () => {
          document
            .querySelectorAll(".characterCard")
            .forEach((c) => c.classList.remove("selected"));
          card.classList.add("selected");
          selectedCharacter = card.dataset.character;
          document.getElementById("startButton").disabled = false;
          document.getElementById("startButton").textContent = "START GAME";
        });
      });

      document.getElementById("startButton").addEventListener("click", () => {
        if (selectedCharacter) {
          startGame();
        }
      });

      function startGame() {
        const characterKeys = Object.keys(CHARACTERS);
        const randomBot =
          characterKeys[Math.floor(Math.random() * characterKeys.length)];

        player1Character = selectedCharacter;
        player2Character = randomBot;

        const p1Char = CHARACTERS[player1Character];
        const p2Char = CHARACTERS[player2Character];

        document.getElementById("player1Icon").textContent = p1Char.icon;
        document.getElementById("player1Name").textContent = "Player";
        document.getElementById("player1Type").textContent = p1Char.name;

        document.getElementById("player2Icon").textContent = p2Char.icon;
        document.getElementById("player2Name").textContent = "Bot";
        document.getElementById("player2Type").textContent = p2Char.name;

        characterSelect.classList.add("hidden");
        canvas.classList.add("active");

        initializeGame();
      }

      function backToMenu() {
        characterSelect.classList.remove("hidden");
        canvas.classList.remove("active");
        document.getElementById("gameOver").style.display = "none";
        gameRunning = false;
      }

      // Physics constants
      const BASE_GRAVITY = 0.4;
      const DAMPING = 0.96;
      const SEGMENT_LENGTH = 30;
      const MAX_DAMAGE_PER_HIT = 15;
      const MIN_VELOCITY_FOR_DAMAGE = 5;
      const DAMAGE_COOLDOWN = 20;

      // MASSIVE SLOW-MO WITH INVINCIBILITY FRAMES!
      function triggerHitStop(damage) {
        const intensity = Math.min(damage / MAX_DAMAGE_PER_HIT, 1);

        // MEGA freeze frame (40-70 frames = 0.67-1.17 seconds)
        freezeFrameTimer = Math.floor(40 + intensity * 30);

        // MEGA slow-mo (600-900 frames = 10-15 SECONDS!)
        slowMoTimer = Math.floor(600 + intensity * 300);

        // Screen shake
        gameContainer.classList.add("shake");
        setTimeout(() => gameContainer.classList.remove("shake"), 500);
      }

      function updateTimeScale() {
        if (freezeFrameTimer > 0) {
          freezeFrameTimer--;
          timeScale = 0; // Complete freeze
        } else if (slowMoTimer > 0) {
          slowMoTimer--;
          // Gradually ramp back to normal speed
          const progress = slowMoTimer / 900;
          timeScale = 0.1 + (1 - progress) * 0.9; // 0.1x to 1.0x speed!
        } else {
          timeScale = 1.0;
        }
      }

      function createImpactRing(x, y) {
        const ring = document.createElement("div");
        ring.className = "impactRing";
        const rect = canvas.getBoundingClientRect();
        ring.style.left = rect.left + x - 15 + "px";
        ring.style.top = rect.top + y - 15 + "px";
        document.body.appendChild(ring);
        setTimeout(() => ring.remove(), 500);
      }

      // Projectile class
      class Projectile {
        constructor(x, y, vx, vy, owner) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.owner = owner;
          this.radius = 8;
          this.lifetime = 120;
        }

        update() {
          this.x += this.vx * timeScale;
          this.y += this.vy * timeScale;
          this.vy += BASE_GRAVITY * 0.5 * timeScale;
          this.lifetime--;
          return this.lifetime > 0 && this.y < canvas.height;
        }

        draw() {
          ctx.fillStyle = "#8B0000";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#DC143C";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // Sausage class with INVINCIBILITY FRAMES
      class Sausage {
        constructor(x, y, characterType, isBot = false) {
          const char = CHARACTERS[characterType];
          this.characterType = characterType;
          this.segments = [];
          this.color = char.color;
          this.health = char.health;
          this.maxHealth = char.health;
          this.isBot = isBot;
          this.targetX = x;
          this.targetY = y;
          this.headX = x;
          this.headY = y;
          this.damageCooldown = 0;
          this.invincibilityFrames = 0; // NEW: i-frames to prevent stuck collisions
          this.hitFlash = 0;
          this.weight = char.weight;
          this.responsiveness = char.responsiveness;
          this.damageMultiplier = char.damage;
          this.segmentWeight = char.segmentWeight;
          this.stiffness = char.stiffness;
          this.hasFlames = char.hasFlames;
          this.elegant = char.elegant;
          this.hasProjectiles = char.hasProjectiles;
          this.projectileCooldown = 0;

          // Create segments
          const numSegments = char.segments;
          for (let i = 0; i < numSegments; i++) {
            this.segments.push({
              x: x + i * SEGMENT_LENGTH,
              y: y,
              prevX: x + i * SEGMENT_LENGTH,
              prevY: y,
            });
          }

          // Bot AI
          this.botAngle = Math.random() * Math.PI * 2;
          this.botRadius = 150;
          this.botSpeed = 0.04;
          this.botCenterX = canvas.width * 0.75;
          this.botCenterY = canvas.height / 2;
        }

        getCollisionRadius() {
          const baseWidth = 45;
          return (baseWidth + this.weight * 15) / 2;
        }

        update() {
          if (this.damageCooldown > 0) this.damageCooldown--;
          if (this.invincibilityFrames > 0) this.invincibilityFrames--;
          if (this.hitFlash > 0) this.hitFlash--;
          if (this.projectileCooldown > 0) this.projectileCooldown--;

          if (this.isBot) {
            this.botAngle += this.botSpeed * timeScale;
            this.targetX =
              this.botCenterX + Math.cos(this.botAngle) * this.botRadius;
            this.targetY =
              this.botCenterY + Math.sin(this.botAngle) * this.botRadius;

            if (Math.random() < 0.01 * timeScale) {
              this.botRadius = 100 + Math.random() * 200;
              this.botSpeed = 0.02 + Math.random() * 0.06;
            }

            if (
              this.hasProjectiles &&
              this.projectileCooldown === 0 &&
              Math.random() < 0.02 * timeScale
            ) {
              this.shootProjectile();
            }
          }

          // Head lerps towards target
          const dx = this.targetX - this.headX;
          const dy = this.targetY - this.headY;

          this.headX += dx * this.responsiveness * timeScale;
          this.headY += dy * this.responsiveness * timeScale;

          // Set first segment to head position
          const head = this.segments[0];
          head.prevX = head.x;
          head.prevY = head.y;
          head.x = this.headX;
          head.y = this.headY;

          // Update segments with Verlet integration
          const gravity = BASE_GRAVITY * this.segmentWeight * timeScale;

          for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            const tempX = segment.x;
            const tempY = segment.y;

            const dampingFactor = DAMPING - this.weight * 0.05;
            const velocityScale = Math.pow(dampingFactor, timeScale);
            segment.x += (segment.x - segment.prevX) * velocityScale;
            segment.y += (segment.y - segment.prevY) * velocityScale;
            segment.y += gravity;

            segment.prevX = tempX;
            segment.prevY = tempY;
          }

          // Constrain segments with STIFFNESS
          const constraintIterations = Math.floor(3 + this.stiffness * 5);

          for (
            let iteration = 0;
            iteration < constraintIterations;
            iteration++
          ) {
            for (let i = 0; i < this.segments.length - 1; i++) {
              const seg1 = this.segments[i];
              const seg2 = this.segments[i + 1];

              const dx = seg2.x - seg1.x;
              const dy = seg2.y - seg1.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance > 0) {
                const difference = SEGMENT_LENGTH - distance;
                const percent =
                  (difference / distance / 2) * (0.5 + this.stiffness * 0.5);
                const offsetX = dx * percent;
                const offsetY = dy * percent;

                if (i !== 0) {
                  seg1.x -= offsetX;
                  seg1.y -= offsetY;
                }
                seg2.x += offsetX;
                seg2.y += offsetY;
              }
            }
          }

          // Boundaries
          for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (segment.y > canvas.height - 20) {
              segment.y = canvas.height - 20;
              const bounceDamping = 0.3 * (1 - this.weight * 0.5);
              segment.prevY =
                segment.y - (segment.y - segment.prevY) * bounceDamping;
            }
            if (segment.x < 20) segment.x = 20;
            if (segment.x > canvas.width - 20) segment.x = canvas.width - 20;
          }

          // Flame particles
          if (this.hasFlames && Math.random() < 0.15 * timeScale) {
            const tail = this.segments[this.segments.length - 1];
            createFlameParticle(tail.x, tail.y);
          }
        }

        shootProjectile() {
          const head = this.segments[0];
          const neck = this.segments[1];
          const angle = Math.atan2(neck.y - head.y, neck.x - head.x);
          const speed = 8;
          projectiles.push(
            new Projectile(
              head.x,
              head.y,
              Math.cos(angle + Math.PI) * speed,
              Math.sin(angle + Math.PI) * speed,
              this
            )
          );
          this.projectileCooldown = 60;
        }

        takeDamage(amount, x, y) {
          // NEW: Check invincibility frames!
          if (this.invincibilityFrames > 0) return;

          if (this.damageCooldown === 0) {
            const defenseFactor = 1 - this.weight * 0.3;
            const actualDamage = amount * defenseFactor;
            this.health -= actualDamage;
            this.damageCooldown = DAMAGE_COOLDOWN;
            this.hitFlash = 10;

            // NEW: Grant invincibility frames (most of the slow-mo duration)
            this.invincibilityFrames = 300; // About 8.3 seconds of immunity

            // TRIGGER FREEZE-FRAME AND SLOW-MO
            triggerHitStop(actualDamage);
            createImpactRing(
              x - canvas.getBoundingClientRect().left,
              y - canvas.getBoundingClientRect().top
            );

            showDamageText(actualDamage, x, y);

            if (this.health <= 0) {
              this.health = 0;
              endGame(this);
            }
          }
        }

        draw() {
          ctx.save();

          // NEW: Flashing when invincible
          if (this.invincibilityFrames > 0) {
            const flashCycle = Math.floor(this.invincibilityFrames / 10) % 2;
            if (flashCycle === 0) {
              ctx.globalAlpha = 0.5;
            }
          }

          // Flash effect
          if (this.hitFlash > 0) {
            ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
            ctx.lineWidth = 50;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(this.segments[0].x, this.segments[0].y);
            for (let i = 1; i < this.segments.length; i++) {
              ctx.lineTo(this.segments[i].x, this.segments[i].y);
            }
            ctx.stroke();
          }

          // Elegant trail
          if (this.elegant) {
            ctx.strokeStyle = "rgba(245, 245, 220, 0.3)";
            ctx.lineWidth = 55;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(this.segments[0].x, this.segments[0].y);
            for (let i = 1; i < this.segments.length; i++) {
              ctx.lineTo(this.segments[i].x, this.segments[i].y);
            }
            ctx.stroke();
          }

          // Main body
          const baseWidth = 45;
          const thickness = baseWidth + this.weight * 15;

          ctx.strokeStyle = this.color;
          ctx.lineWidth = thickness;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          ctx.moveTo(this.segments[0].x, this.segments[0].y);
          for (let i = 1; i < this.segments.length; i++) {
            ctx.lineTo(this.segments[i].x, this.segments[i].y);
          }
          ctx.stroke();

          // Stripes
          const stripeColor =
            this.color === "#F5F5DC"
              ? "#D3D3D3"
              : this.color === "#DC143C"
                ? "#8B0000"
                : "#654321";
          ctx.strokeStyle = stripeColor;
          ctx.lineWidth = 3;

          for (let i = 0; i < this.segments.length - 1; i++) {
            const seg = this.segments[i];
            const nextSeg = this.segments[i + 1];
            const angle = Math.atan2(nextSeg.y - seg.y, nextSeg.x - seg.x);
            const perpAngle = angle + Math.PI / 2;
            const stripeLength = thickness / 2;

            ctx.beginPath();
            ctx.moveTo(
              seg.x + Math.cos(perpAngle) * stripeLength,
              seg.y + Math.sin(perpAngle) * stripeLength
            );
            ctx.lineTo(
              seg.x - Math.cos(perpAngle) * stripeLength,
              seg.y - Math.sin(perpAngle) * stripeLength
            );
            ctx.stroke();
          }

          // Eyes
          const head = this.segments[0];
          const neck = this.segments[1];
          const headAngle = Math.atan2(neck.y - head.y, neck.x - head.x);
          const eyeOffset = 12;
          const eyeDistance = 15;

          const leftEyeX =
            head.x +
            Math.cos(headAngle + Math.PI / 2) * eyeDistance +
            Math.cos(headAngle) * eyeOffset;
          const leftEyeY =
            head.y +
            Math.sin(headAngle + Math.PI / 2) * eyeDistance +
            Math.sin(headAngle) * eyeOffset;
          const rightEyeX =
            head.x -
            Math.cos(headAngle + Math.PI / 2) * eyeDistance +
            Math.cos(headAngle) * eyeOffset;
          const rightEyeY =
            head.y -
            Math.sin(headAngle + Math.PI / 2) * eyeDistance +
            Math.sin(headAngle) * eyeOffset;

          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(leftEyeX, leftEyeY, 7, 0, Math.PI * 2);
          ctx.arc(rightEyeX, rightEyeY, 7, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(leftEyeX, leftEyeY, 3, 0, Math.PI * 2);
          ctx.arc(rightEyeX, rightEyeY, 3, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      let player1, player2;

      function initializeGame() {
        player1 = new Sausage(300, 300, player1Character);
        player2 = new Sausage(900, 300, player2Character, true);
        projectiles = [];
        timeScale = 1.0;
        freezeFrameTimer = 0;
        slowMoTimer = 0;
        gameRunning = true;
        gameLoop();
      }

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
        if (player1) {
          player1.targetX = mouseX;
          player1.targetY = mouseY;
        }
      });

      canvas.addEventListener("click", () => {
        if (
          player1 &&
          player1.hasProjectiles &&
          player1.projectileCooldown === 0 &&
          gameRunning
        ) {
          player1.shootProjectile();
        }
      });

      document.addEventListener("mousemove", (e) => {
        cursorElement.style.left = e.clientX + "px";
        cursorElement.style.top = e.clientY + "px";
      });

      function createFlameParticle(x, y) {
        const particle = document.createElement("div");
        particle.className = "particle";
        particle.style.left = x + canvas.getBoundingClientRect().left + "px";
        particle.style.top = y + canvas.getBoundingClientRect().top + "px";
        particle.style.width = 5 + Math.random() * 10 + "px";
        particle.style.height = particle.style.width;
        particle.style.background = Math.random() > 0.5 ? "#ff6b00" : "#ff0000";
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 500);
      }

      function showDamageText(damage, x, y) {
        const damageElement = document.createElement("div");
        damageElement.className = "damageText";
        damageElement.textContent = `-${Math.round(damage)}`;
        damageElement.style.left = x + "px";
        damageElement.style.top = y + "px";
        gameContainer.appendChild(damageElement);
        setTimeout(() => damageElement.remove(), 1000);
      }

      // OPTIMIZED COLLISION DETECTION
      function checkCollision(sausage1, sausage2) {
        const radius1 = sausage1.getCollisionRadius();
        const radius2 = sausage2.getCollisionRadius();
        const collisionDistance = radius1 + radius2;

        // Early exit if sausages are far apart
        const center1X =
          sausage1.segments[Math.floor(sausage1.segments.length / 2)].x;
        const center1Y =
          sausage1.segments[Math.floor(sausage1.segments.length / 2)].y;
        const center2X =
          sausage2.segments[Math.floor(sausage2.segments.length / 2)].x;
        const center2Y =
          sausage2.segments[Math.floor(sausage2.segments.length / 2)].y;

        const centerDist = Math.sqrt(
          Math.pow(center1X - center2X, 2) + Math.pow(center1Y - center2Y, 2)
        );

        if (
          centerDist >
          (sausage1.segments.length + sausage2.segments.length) * SEGMENT_LENGTH
        ) {
          return;
        }

        const step1 = Math.max(1, Math.floor(sausage1.segments.length / 6));
        const step2 = Math.max(1, Math.floor(sausage2.segments.length / 6));

        for (let i = 0; i < sausage1.segments.length; i += step1) {
          const seg1 = sausage1.segments[i];

          for (let j = 0; j < sausage2.segments.length; j += step2) {
            const seg2 = sausage2.segments[j];

            const dx = seg1.x - seg2.x;
            const dy = seg1.y - seg2.y;
            const distSq = dx * dx + dy * dy;
            const collisionDistSq = collisionDistance * collisionDistance;

            if (distSq < collisionDistSq) {
              const distance = Math.sqrt(distSq);

              // Calculate velocities
              const vel1Sq =
                Math.pow(seg1.x - seg1.prevX, 2) +
                Math.pow(seg1.y - seg1.prevY, 2);
              const vel2Sq =
                Math.pow(seg2.x - seg2.prevX, 2) +
                Math.pow(seg2.y - seg2.prevY, 2);

              // Apply damage based on velocity difference
              if (vel1Sq > vel2Sq) {
                const vel1 = Math.sqrt(vel1Sq);
                const vel2 = Math.sqrt(vel2Sq);
                const velocityDiff = vel1 - vel2;

                if (velocityDiff > MIN_VELOCITY_FOR_DAMAGE) {
                  const rawDamage =
                    (velocityDiff - MIN_VELOCITY_FOR_DAMAGE) * 0.5;
                  const damage = Math.min(rawDamage, MAX_DAMAGE_PER_HIT);
                  const rect = canvas.getBoundingClientRect();
                  const actualDamage = damage * sausage1.damageMultiplier;
                  sausage2.takeDamage(
                    actualDamage,
                    rect.left + seg2.x,
                    rect.top + seg2.y
                  );
                }
              } else if (vel2Sq > vel1Sq) {
                const vel1 = Math.sqrt(vel1Sq);
                const vel2 = Math.sqrt(vel2Sq);
                const velocityDiff = vel2 - vel1;

                if (velocityDiff > MIN_VELOCITY_FOR_DAMAGE) {
                  const rawDamage =
                    (velocityDiff - MIN_VELOCITY_FOR_DAMAGE) * 0.5;
                  const damage = Math.min(rawDamage, MAX_DAMAGE_PER_HIT);
                  const rect = canvas.getBoundingClientRect();
                  const actualDamage = damage * sausage2.damageMultiplier;
                  sausage1.takeDamage(
                    actualDamage,
                    rect.left + seg1.x,
                    rect.top + seg1.y
                  );
                }
              }

              // STRONGER COLLISION RESPONSE - push apart more!
              const overlap = collisionDistance - distance;
              const angle = Math.atan2(dy, dx);

              const totalMass = sausage1.weight + sausage2.weight;
              const mass1Ratio = sausage2.weight / totalMass;
              const mass2Ratio = sausage1.weight / totalMass;

              // INCREASED push force to separate them better
              const pushForce = overlap * 1.2;

              if (i === 0) {
                seg2.x -= Math.cos(angle) * pushForce * 1.5;
                seg2.y -= Math.sin(angle) * pushForce * 1.5;
                seg2.prevX = seg2.x - (seg2.x - seg2.prevX) * 0.3;
                seg2.prevY = seg2.y - (seg2.y - seg2.prevY) * 0.3;
              } else if (j === 0) {
                seg1.x += Math.cos(angle) * pushForce * 1.5;
                seg1.y += Math.sin(angle) * pushForce * 1.5;
                seg1.prevX = seg1.x - (seg1.x - seg1.prevX) * 0.3;
                seg1.prevY = seg1.y - (seg1.y - seg1.prevY) * 0.3;
              } else {
                seg1.x += Math.cos(angle) * pushForce * mass1Ratio;
                seg1.y += Math.sin(angle) * pushForce * mass1Ratio;
                seg2.x -= Math.cos(angle) * pushForce * mass2Ratio;
                seg2.y -= Math.sin(angle) * pushForce * mass2Ratio;

                seg1.prevX = seg1.x - (seg1.x - seg1.prevX) * 0.4;
                seg1.prevY = seg1.y - (seg1.y - seg1.prevY) * 0.4;
                seg2.prevX = seg2.x - (seg2.x - seg2.prevX) * 0.4;
                seg2.prevY = seg2.y - (seg2.y - seg2.prevY) * 0.4;
              }
            }
          }
        }
      }

      function checkProjectileCollisions() {
        projectiles = projectiles.filter((proj) => {
          const target = proj.owner === player1 ? player2 : player1;
          for (let seg of target.segments) {
            const dx = proj.x - seg.x;
            const dy = proj.y - seg.y;
            if (dx * dx + dy * dy < 625) {
              const rect = canvas.getBoundingClientRect();
              target.takeDamage(8, rect.left + seg.x, rect.top + seg.y);
              return false;
            }
          }
          return proj.update();
        });
      }

      function updateHealthBars() {
        const p1Percent = (player1.health / player1.maxHealth) * 100;
        const p2Percent = (player2.health / player2.maxHealth) * 100;

        document.getElementById("player1Health").style.width = p1Percent + "%";
        document.getElementById("player2Health").style.width = p2Percent + "%";
        document.getElementById("player1HealthText").textContent =
          `${Math.ceil(player1.health)} / ${player1.maxHealth}`;
        document.getElementById("player2HealthText").textContent =
          `${Math.ceil(player2.health)} / ${player2.maxHealth}`;
      }

      function endGame(loser) {
        gameRunning = false;
        const winner =
          loser === player1
            ? CHARACTERS[player2Character].name
            : CHARACTERS[player1Character].name;
        const winnerIcon =
          loser === player1
            ? CHARACTERS[player2Character].icon
            : CHARACTERS[player1Character].icon;

        document.getElementById("winnerText").textContent =
          winnerIcon + " VICTORY! " + winnerIcon;
        document.getElementById("winnerSubtext").textContent =
          winner + " Wins!";
        document.getElementById("gameOver").style.display = "block";
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#87CEEB");
        gradient.addColorStop(1, "#E0F6FF");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#8B7355";
        ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
        ctx.fillStyle = "#90EE90";
        ctx.fillRect(0, canvas.height - 55, canvas.width, 10);
      }

      function gameLoop() {
        if (!gameRunning) return;

        drawBackground();

        // Update time scale for freeze-frame and slow-mo
        updateTimeScale();

        player1.update();
        player2.update();
        checkCollision(player1, player2);
        checkProjectileCollisions();
        updateHealthBars();

        player1.draw();
        player2.draw();
        projectiles.forEach((proj) => proj.draw());

        requestAnimationFrame(gameLoop);
      }
    </script>
  </body>
</html>
