<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>AR Sausage Duel - NEO</title>
    <style>
      /* --- NEOBRUTALIST FONT IMPORTS --- */
      @import url("https://fonts.googleapis.com/css2?family=Lexend+Mega:wght@700&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap");

      :root {
        --neo-black: #121212;
        --neo-white: #ffffff;
        --neo-primary: #ffeb3b;
        --neo-accent: #ff00ff;
        --neo-success: #00ff9d;
        --neo-danger: #ff4757;
        --border-thick: 3px solid var(--neo-black);
        --shadow-hard: 4px 4px 0px var(--neo-black);
        --shadow-hover: 6px 6px 0px var(--neo-black);
        --shadow-click: 0px 0px 0px var(--neo-black);
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: var(--neo-black);
        font-family: "Space Mono", monospace;
        color: var(--neo-black);
        user-select: none;
        -webkit-user-select: none;
      }

      #video-feed {
        position: absolute;
        top: 0;
        left: 0;
        width: 1px;
        height: 1px;
        opacity: 0.01;
        pointer-events: none;
        z-index: -1;
      }

      .game-canvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }

      #bg-canvas {
        z-index: 1;
      }
      #main-canvas {
        z-index: 2;
      }

      .neo-btn {
        font-family: "Lexend Mega", sans-serif;
        font-size: 16px;
        text-transform: uppercase;
        background: var(--neo-primary);
        color: var(--neo-black);
        border: var(--border-thick);
        box-shadow: var(--shadow-hard);
        padding: 15px 25px;
        cursor: pointer;
        transition:
          transform 0.1s,
          box-shadow 0.1s;
        width: 100%;
        max-width: 300px;
        text-align: center;
      }

      .neo-btn:active {
        transform: translate(4px, 4px);
        box-shadow: var(--shadow-click);
      }

      .neo-btn:disabled {
        background: #ccc;
        color: #666;
        cursor: not-allowed;
        box-shadow: none;
        transform: translate(2px, 2px);
      }

      .neo-btn.secondary {
        background: var(--neo-white);
      }
      .neo-btn.danger {
        background: var(--neo-danger);
        color: var(--neo-white);
      }
      .neo-btn.small {
        padding: 10px;
        font-size: 12px;
        max-width: 200px;
      }

      input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 15px;
        background: var(--neo-white);
        border: var(--border-thick);
        margin: 10px 0;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 25px;
        height: 25px;
        background: var(--neo-accent);
        border: var(--border-thick);
        cursor: pointer;
        box-shadow: 2px 2px 0 var(--neo-black);
      }

      .screen-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        background: rgba(255, 235, 59, 0.95);
        backdrop-filter: blur(5px);
      }

      #permission-screen {
        background: var(--neo-primary);
        z-index: 200;
      }

      h1.title {
        font-family: "Lexend Mega", sans-serif;
        font-size: clamp(2rem, 8vw, 4rem);
        text-align: center;
        margin: 0 0 10px 0;
        color: var(--neo-black);
        text-shadow: 4px 4px 0 var(--neo-white);
        line-height: 1;
      }

      .subtitle {
        font-weight: bold;
        margin-bottom: 40px;
        background: var(--neo-black);
        color: var(--neo-white);
        padding: 5px 15px;
        transform: rotate(-2deg);
      }

      .perm-list {
        width: 100%;
        max-width: 400px;
        background: var(--neo-white);
        border: var(--border-thick);
        box-shadow: var(--shadow-hard);
        margin-bottom: 30px;
      }

      .perm-item {
        display: flex;
        align-items: center;
        padding: 15px;
        border-bottom: var(--border-thick);
      }
      .perm-item:last-child {
        border-bottom: none;
      }

      .perm-icon {
        font-size: 24px;
        margin-right: 15px;
      }
      .perm-text {
        flex-grow: 1;
        font-weight: bold;
      }
      .perm-status {
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        border: 2px solid var(--neo-black);
        text-transform: uppercase;
      }
      .perm-pending {
        background: #eee;
      }
      .perm-granted {
        background: var(--neo-success);
      }
      .perm-denied {
        background: var(--neo-danger);
        color: white;
      }

      #character-select {
        background: var(--neo-primary);
        z-index: 190;
        display: none;
        overflow-y: auto;
        padding: 40px 20px;
      }

      .char-grid {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 500px;
        margin-bottom: 30px;
      }

      .char-card {
        width: 140px;
        background: var(--neo-white);
        border: var(--border-thick);
        box-shadow: var(--shadow-hard);
        padding: 15px;
        cursor: pointer;
        transition: transform 0.2s;
        text-align: center;
      }
      .char-card:hover {
        transform: translateY(-3px);
      }
      .char-card.selected {
        background: var(--neo-accent);
        color: var(--neo-white);
        transform: translate(4px, 4px);
        box-shadow: var(--shadow-click);
      }

      .char-icon {
        font-size: 2.5rem;
        display: block;
        margin-bottom: 5px;
      }
      .char-name {
        font-family: "Lexend Mega", sans-serif;
        font-size: 0.8rem;
        font-weight: bold;
        text-transform: uppercase;
        margin-bottom: 8px;
      }

      .stat-row {
        display: flex;
        align-items: center;
        gap: 5px;
        margin: 4px 0;
        font-size: 10px;
      }
      .stat-label {
        width: 30px;
        text-align: left;
      }
      .stat-bar {
        flex: 1;
        height: 6px;
        background: rgba(0, 0, 0, 0.2);
        position: relative;
      }
      .stat-fill {
        height: 100%;
        background: var(--neo-black);
      }
      .char-card.selected .stat-fill {
        background: var(--neo-white);
      }

      .char-trait {
        font-size: 9px;
        background: var(--neo-black);
        color: var(--neo-white);
        padding: 2px 6px;
        margin-top: 8px;
        display: inline-block;
      }
      .char-card.selected .char-trait {
        background: var(--neo-white);
        color: var(--neo-black);
      }

      #loading {
        background: var(--neo-black);
        color: var(--neo-white);
        z-index: 150;
      }
      .loader-bar {
        width: 100%;
        max-width: 300px;
        height: 25px;
        background: var(--neo-black);
        border: 2px solid var(--neo-white);
        margin-top: 20px;
        position: relative;
      }
      .loader-fill {
        height: 100%;
        width: 100%;
        background: var(--neo-accent);
        transform-origin: left;
        animation: loadAnim 2s infinite ease-in-out;
      }

      #calibration-screen {
        justify-content: flex-start; /* Changed from space-between */
        background: none;
        backdrop-filter: none;
        padding: 0;
        z-index: 40;
      }

      #cal-top-bar {
        width: 100%;
        background: var(--neo-primary);
        border-bottom: var(--border-thick);
        padding: 15px;
        text-align: center;
        box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        pointer-events: none;
      }

      #cal-bottom-deck {
        position: absolute; /* Added absolute positioning */
        bottom: 0;
        left: 0;
        width: 100%;
        background: var(--neo-white);
        border-top: var(--border-thick);
        padding: 20px 20px 30px 20px; /* Extra padding for bottom safe area */
        display: flex;
        flex-direction: column;
        gap: 15px;
        box-shadow: 0 -4px 0 rgba(0, 0, 0, 0.2);
      }

      .cal-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .cal-row label {
        font-weight: bold;
        min-width: 50px;
        font-size: 0.8rem;
        font-family: "Lexend Mega";
      }

      #instruction-screen {
        background: var(--neo-primary);
        z-index: 45;
        display: none;
      }

      .instruct-card {
        background: var(--neo-white);
        border: var(--border-thick);
        box-shadow: var(--shadow-hard);
        padding: 30px;
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .instruct-step {
        margin: 20px 0;
        font-size: 16px;
        text-align: left;
        line-height: 1.5;
        border-bottom: 2px dashed #ccc;
        padding-bottom: 10px;
      }
      .instruct-step:last-child {
        border-bottom: none;
      }
      .step-icon {
        font-size: 24px;
        margin-right: 10px;
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: none;
        flex-direction: column;
        justify-content: space-between;
      }

      .hud-top {
        display: flex;
        justify-content: space-between;
        padding: 10px;
        width: 100%;
        gap: 10px;
        pointer-events: none;
      }

      .health-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        max-width: 45%;
      }

      .health-label {
        font-family: "Lexend Mega";
        font-size: 10px;
        background: var(--neo-black);
        color: var(--neo-white);
        padding: 2px 5px;
        width: fit-content;
        margin-bottom: -2px;
        z-index: 2;
        border: 2px solid var(--neo-black);
      }

      .health-bar-frame {
        height: 25px;
        background: var(--neo-white);
        border: 3px solid var(--neo-black);
        position: relative;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
      }

      .bar-fill {
        height: 100%;
        width: 100%;
        transition: width 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        border-right: 2px solid var(--neo-black);
      }

      .hud-bottom {
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: none;
      }

      #tracking-indicator {
        margin-bottom: 20px;
        padding: 10px 20px;
        border: 3px solid var(--neo-black);
        font-weight: bold;
        font-family: "Lexend Mega";
        font-size: 12px;
        text-transform: uppercase;
        box-shadow: 4px 4px 0 var(--neo-black);
        transition: all 0.2s;
      }
      .tracking-good {
        background: var(--neo-success);
        color: var(--neo-black);
      }
      .tracking-ok {
        background: var(--neo-primary);
        color: var(--neo-black);
      }
      .tracking-lost {
        background: var(--neo-danger);
        color: var(--neo-white);
      }

      #ammo-indicator {
        display: none;
        margin-bottom: 10px;
        padding: 8px 15px;
        background: var(--neo-white);
        border: 3px solid var(--neo-black);
        font-family: "Lexend Mega";
        font-size: 11px;
        box-shadow: 3px 3px 0 var(--neo-black);
      }
      #ammo-indicator.ready {
        background: var(--neo-success);
      }
      #ammo-indicator.cooldown {
        background: #ccc;
      }

      #gesture-indicator {
        display: none;
        padding: 8px 15px;
        background: var(--neo-accent);
        color: var(--neo-white);
        border: 3px solid var(--neo-black);
        font-family: "Lexend Mega";
        font-size: 11px;
        box-shadow: 3px 3px 0 var(--neo-black);
        margin-bottom: 10px;
      }

      #top-controls {
        position: absolute;
        top: 60px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-end;
        pointer-events: auto;
      }

      .mini-btn {
        background: var(--neo-white);
        border: 2px solid var(--neo-black);
        padding: 5px 8px;
        font-size: 10px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 2px 2px 0 var(--neo-black);
      }
      .mini-btn:active {
        transform: translate(1px, 1px);
        box-shadow: 1px 1px 0 var(--neo-black);
      }

      #debug-panel {
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid var(--neo-black);
        padding: 10px;
        font-size: 10px;
        display: none;
        margin-top: 5px;
        pointer-events: auto;
        min-width: 150px;
      }

      #win-screen {
        position: fixed; /* Fixed to cover everything */
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(255, 235, 59, 0.95);
        display: none;
        z-index: 999;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #win-msg {
        font-family: "Lexend Mega";
        font-size: 15vw;
        line-height: 1;
        color: var(--neo-black);
        text-shadow: 5px 5px 0 var(--neo-white);
        margin-bottom: 40px;
        text-align: center;
      }

      .dmg-text {
        position: absolute;
        color: var(--neo-white);
        font-family: "Lexend Mega";
        font-size: 40px;
        text-shadow: 4px 4px 0 var(--neo-black);
        -webkit-text-stroke: 2px var(--neo-black);
        pointer-events: none;
        z-index: 20;
        animation: popUp 0.8s forwards cubic-bezier(0.18, 0.89, 0.32, 1.28);
      }

      @keyframes popUp {
        0% {
          transform: translateY(0) scale(0.5);
          opacity: 0;
        }
        50% {
          transform: translateY(-50px) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translateY(-100px) scale(1);
          opacity: 0;
        }
      }

      @keyframes loadAnim {
        0% {
          transform: scaleX(0);
        }
        50% {
          transform: scaleX(0.5);
        }
        100% {
          transform: scaleX(1);
        }
      }

      .vs-display {
        display: flex;
        align-items: center;
        gap: 20px;
        margin: 20px 0 30px 0;
        padding: 15px 25px;
        background: var(--neo-white);
        border: var(--border-thick);
        box-shadow: var(--shadow-hard);
      }
      .vs-char {
        text-align: center;
      }
      .vs-char .char-icon {
        font-size: 2rem;
      }
      .vs-char .char-name {
        font-size: 0.7rem;
        margin-top: 5px;
      }
      .vs-text {
        font-family: "Lexend Mega";
        font-size: 1.5rem;
        color: var(--neo-danger);
      }
      .alt-badge {
        font-size: 8px;
        background: #333;
        color: #fff;
        padding: 2px 4px;
        margin-top: 3px;
        display: inline-block;
      }
    </style>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "locar": "https://cdn.jsdelivr.net/npm/locar@0.1.5/dist/locar.es.js",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
        }
      }
    </script>
  </head>
  <body>
    <!-- PERMISSION SCREEN -->
    <div id="permission-screen" class="screen-overlay">
      <h1 class="title">SAUSAGE<br />DUEL</h1>
      <div class="subtitle">AR BRAWLER</div>

      <div class="perm-list">
        <div class="perm-item">
          <span class="perm-icon">üì∑</span>
          <span class="perm-text">Camera</span>
          <span class="perm-status perm-pending" id="perm-camera">Wait</span>
        </div>
        <div class="perm-item">
          <span class="perm-icon">üîÑ</span>
          <span class="perm-text">Orientation</span>
          <span class="perm-status perm-pending" id="perm-orientation"
            >Wait</span
          >
        </div>
        <div class="perm-item">
          <span class="perm-icon">üì±</span>
          <span class="perm-text">Motion</span>
          <span class="perm-status perm-pending" id="perm-motion">Wait</span>
        </div>
      </div>

      <button id="request-perms-btn" class="neo-btn">Start Game</button>
      <div style="margin-top: 15px">
        <button id="recalibrate-btn" class="neo-btn secondary small">
          FORCE RECALIBRATE
        </button>
      </div>

      <div
        id="perm-error"
        style="
          color: white;
          background: black;
          padding: 5px;
          margin-top: 10px;
          display: none;
        "
      ></div>
    </div>

    <!-- CHARACTER SELECT SCREEN -->
    <div id="character-select" class="screen-overlay">
      <h1 class="title" style="font-size: clamp(1.5rem, 6vw, 2.5rem)">
        CHOOSE YOUR<br />FIGHTER
      </h1>
      <div class="char-grid" id="char-grid"></div>
      <div class="vs-display" id="vs-display" style="display: none">
        <div class="vs-char" id="vs-player"></div>
        <div class="vs-text">VS</div>
        <div class="vs-char" id="vs-bot"></div>
      </div>
      <button id="confirm-char-btn" class="neo-btn" disabled>
        SELECT FIGHTER
      </button>
    </div>

    <!-- MAIN GAME LAYERS -->
    <video id="video-feed" playsinline autoplay muted></video>
    <canvas id="bg-canvas" class="game-canvas"></canvas>
    <canvas id="main-canvas" class="game-canvas"></canvas>

    <!-- LOADING -->
    <div id="loading" class="screen-overlay" style="display: none">
      <div style="font-family: &quot;Lexend Mega&quot;; font-size: 24px">
        INITIALIZING
      </div>
      <div class="loader-bar"><div class="loader-fill"></div></div>
      <div id="status-text" style="margin-top: 10px; opacity: 0.7">
        Loading models...
      </div>
    </div>

    <!-- CALIBRATION -->
    <div id="calibration-screen" class="screen-overlay" style="display: none">
      <div id="cal-top-bar">
        <div style="font-family: &quot;Lexend Mega&quot;; font-size: 1.2rem">
          ALIGN HAND
        </div>
        <div style="font-size: 0.8rem; font-weight: bold">
          Match the green ghost to your hand
        </div>
      </div>
      <div id="cal-bottom-deck">
        <div class="cal-row">
          <label>X</label>
          <input type="range" id="cal-x" min="-200" max="200" value="0" />
        </div>
        <div class="cal-row">
          <label>Y</label>
          <input type="range" id="cal-y" min="-200" max="200" value="0" />
        </div>
        <div class="cal-row" style="flex-wrap: wrap">
          <label>WIDTH</label>
          <input
            type="range"
            id="cal-depth"
            min="-10"
            max="5"
            step="0.1"
            value="-10"
          />
          <div
            style="
              width: 100%;
              font-size: 9px;
              color: #666;
              margin-top: -5px;
              margin-bottom: 5px;
              padding-left: 60px;
            "
          >
            Changes thickness of each segment effectively when projected
          </div>
        </div>
        <div class="cal-row" style="margin-top: 10px">
          <button
            id="cal-mirror-btn"
            class="neo-btn secondary"
            style="flex: 1; padding: 15px 5px; font-size: 12px"
          >
            Mirror: OFF
          </button>
          <button id="finish-cal-btn" class="neo-btn" style="flex: 2">
            SAVE & NEXT
          </button>
        </div>
      </div>
    </div>

    <!-- INSTRUCTION SCREEN -->
    <div id="instruction-screen" class="screen-overlay">
      <div class="instruct-card">
        <h2 style="font-family: &quot;Lexend Mega&quot;; margin-bottom: 20px">
          HOW TO FIGHT
        </h2>
        <div class="instruct-step">
          <span class="step-icon">üñï</span>
          <strong>MIDDLE FINGER</strong><br />
          Your middle finger controls the sausage direction.
        </div>
        <div class="instruct-step">
          <span class="step-icon">üí®</span>
          <strong>FLICK TO ATTACK</strong><br />
          Quickly flick your hand/wrist forward to strike!
        </div>
        <div class="instruct-step" id="special-instruct">
          <span class="step-icon">üõ°Ô∏è</span>
          <strong>BLOCK</strong><br />
          Hold your hand steady to block incoming attacks.
        </div>
        <button id="start-game-btn" class="neo-btn" style="margin-top: 20px">
          I'M READY!
        </button>
      </div>
    </div>

    <!-- IN-GAME HUD -->
    <div id="ui-layer">
      <div class="hud-top">
        <div class="health-container">
          <div class="health-label" id="p1-name">YOU</div>
          <div class="health-bar-frame">
            <div class="bar-fill" id="p1-bar"></div>
          </div>
        </div>

        <div class="health-container" style="align-items: flex-end">
          <div class="health-label" id="p2-name">BOT</div>
          <div class="health-bar-frame" style="width: 100%">
            <div class="bar-fill" id="p2-bar" style="float: right"></div>
          </div>
        </div>
      </div>

      <div id="top-controls">
        <button id="toggle-debug-panel" class="mini-btn">DEBUG</button>

        <div id="debug-panel">
          <div>FPS: <span id="dbg-fps">0</span></div>
          <div>Frame: <span id="dbg-frame-time">0</span>ms</div>
          <div
            style="
              margin-top: 5px;
              border-top: 1px dashed #000;
              padding-top: 5px;
            "
          >
            <div>Hand: <span id="dbg-hand">No</span></div>
            <div>Conf: <span id="dbg-conf">0%</span></div>
            <div>Gesture: <span id="dbg-gesture">-</span></div>
          </div>
          <div style="margin-top: 5px">
            <button
              id="toggle-debug-vis"
              class="mini-btn"
              style="width: 100%; margin-bottom: 2px"
            >
              Show Mesh
            </button>
            <button
              id="toggle-occl"
              class="mini-btn"
              style="width: 100%; background: #cf6859; color: white"
            >
              Occlusion ON
            </button>
          </div>
        </div>
      </div>

      <div class="hud-bottom">
        <div id="gesture-indicator">üëÜ FINGER GUN</div>
        <div id="ammo-indicator" class="ready">üéØ AUTO-AIM READY</div>
        <div id="tracking-indicator" class="tracking-lost">NO HAND</div>
      </div>
    </div>

    <!-- WIN SCREEN -->
    <div id="win-screen">
      <div id="win-msg">VICTORY</div>
      <button
        id="rematch-btn"
        class="neo-btn"
        style="width: auto; padding: 20px 40px; font-size: 24px"
      >
        REMATCH
      </button>
    </div>

    <script type="module">
      import * as THREE from "three";
      import * as LocAR from "locar";
      import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

      // ============================================================
      // STORAGE
      // ============================================================
      const STORAGE_KEY = "neo_sausage_cal_v1";

      function saveCalibration() {
        const data = {
          x: calibrationX,
          y: calibrationY,
          depth: depthBias,
          mirror: mirrorMode,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      }

      function loadCalibration() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          try {
            const data = JSON.parse(raw);
            calibrationX = data.x;
            calibrationY = data.y;
            depthBias = data.depth;
            mirrorMode = data.mirror;

            // Update UI inputs to match
            document.getElementById("cal-x").value = calibrationX;
            document.getElementById("cal-y").value = calibrationY;
            document.getElementById("cal-depth").value = depthBias;
            document.getElementById("cal-mirror-btn").textContent = mirrorMode
              ? "Mirror: ON"
              : "Mirror: OFF";
            return true;
          } catch (e) {
            console.error("Failed to load cal", e);
          }
        }
        return false;
      }

      function clearCalibration() {
        localStorage.removeItem(STORAGE_KEY);
        // Reset defaults
        calibrationX = 0;
        calibrationY = 0;
        depthBias = -10;
        mirrorMode = false;
      }

      // ============================================================
      // CHARACTER DEFINITIONS
      // ============================================================
      const CHARACTERS = {
        frankfurter: {
          name: "Frank",
          icon: "üå≠",
          color: 0xffaaaa,
          colorHex: "#ffaaaa",
          segments: 8,
          weight: 1.0,
          responsiveness: 0.25,
          damage: 1.0,
          health: 100,
          trait: null,
          traitDesc: "Balanced",
        },
        bratwurst: {
          name: "Brat",
          icon: "ü•ñ",
          color: 0xd2691e,
          colorHex: "#d2691e",
          segments: 12,
          weight: 1.8,
          responsiveness: 0.1,
          damage: 1.5,
          health: 140,
          trait: null,
          traitDesc: "Tank",
        },
        chorizo: {
          name: "Rizo",
          icon: "üå∂Ô∏è",
          color: 0xff4400,
          colorHex: "#ff4400",
          segments: 7,
          weight: 0.8,
          responsiveness: 0.35,
          damage: 1.2,
          health: 85,
          trait: "fire",
          traitDesc: "üî• Fire Trail",
        },
        boudin: {
          name: "Boudin",
          icon: "‚ö™",
          color: 0xf5f5dc,
          colorHex: "#f5f5dc",
          segments: 9,
          weight: 1.1,
          responsiveness: 0.18,
          damage: 1.0,
          health: 110,
          trait: "fire",
          traitDesc: "üî• Ghost Fire",
        },
        salami: {
          name: "Salami",
          icon: "üçñ",
          color: 0xcc3333,
          colorHex: "#cc3333",
          segments: 8,
          weight: 1.2,
          responsiveness: 0.15,
          damage: 0.9,
          health: 120,
          trait: "projectile",
          traitDesc: "üéØ Auto-Aim",
        },
      };

      // Darken a hex color for "alt" version
      function darkenColor(hex, factor = 0.5) {
        const color = new THREE.Color(hex);
        color.r *= factor;
        color.g *= factor;
        color.b *= factor;
        return color.getHex();
      }

      function darkenHexString(hexStr, factor = 0.5) {
        const color = new THREE.Color(hexStr);
        color.r *= factor;
        color.g *= factor;
        color.b *= factor;
        return "#" + color.getHexString();
      }

      // Selected characters
      let playerCharKey = null;
      let botCharKey = null;
      let playerConfig = null;
      let botConfig = null;

      // ============================================================
      // CALIBRATION STATE
      // ============================================================
      let calibrationX = 0;
      let calibrationY = 0;
      let depthBias = -10; // Default to thinnest
      let mirrorMode = false;
      let forceRecalibrate = false;

      // SINGLE LOCKED PROFILE (LOW)
      const LOCKED_PROFILE = {
        handInterval: 50,
        physicsIterations: 10,
        sausageSegments: 8,
        tubeSegments: 8,
        tubeRadialSegments: 3,
      };
      let currentProfile = LOCKED_PROFILE;

      // ============================================================
      // PERMISSION HANDLING
      // ============================================================
      const permScreen = document.getElementById("permission-screen");
      const permBtn = document.getElementById("request-perms-btn");
      const recalibrateBtn = document.getElementById("recalibrate-btn");
      const permError = document.getElementById("perm-error");
      const permCamera = document.getElementById("perm-camera");
      const permOrientation = document.getElementById("perm-orientation");
      const permMotion = document.getElementById("perm-motion");

      let cameraStream = null;

      recalibrateBtn.addEventListener("click", () => {
        clearCalibration();
        forceRecalibrate = true;
        recalibrateBtn.textContent = "DONE (WILL SHOW CALIB MENU)";
        recalibrateBtn.disabled = true;
      });

      function updatePermStatus(element, status) {
        element.className = "perm-status";
        const statusMap = {
          checking: ["perm-pending", "Checking"],
          granted: ["perm-granted", "OK"],
          denied: ["perm-denied", "NO"],
          unavailable: ["perm-granted", "N/A"],
        };
        const [cls, txt] = statusMap[status] || ["perm-pending", "Wait"];
        element.classList.add(cls);
        element.textContent = txt;
      }

      async function requestCameraPermission() {
        updatePermStatus(permCamera, "checking");
        try {
          cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "environment",
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30, max: 30 },
            },
          });
          updatePermStatus(permCamera, "granted");
          return true;
        } catch (err) {
          updatePermStatus(permCamera, "denied");
          throw new Error("Camera access denied.");
        }
      }

      async function requestOrientationPermission() {
        updatePermStatus(permOrientation, "checking");
        if (typeof DeviceOrientationEvent === "undefined") {
          updatePermStatus(permOrientation, "unavailable");
          return true;
        }
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          try {
            const permission = await DeviceOrientationEvent.requestPermission();
            updatePermStatus(
              permOrientation,
              permission === "granted" ? "granted" : "denied"
            );
            if (permission !== "granted")
              throw new Error("Orientation denied.");
            return true;
          } catch (err) {
            updatePermStatus(permOrientation, "denied");
            throw err;
          }
        }
        updatePermStatus(permOrientation, "granted");
        return true;
      }

      async function requestMotionPermission() {
        updatePermStatus(permMotion, "checking");
        if (typeof DeviceMotionEvent === "undefined") {
          updatePermStatus(permMotion, "unavailable");
          return true;
        }
        if (typeof DeviceMotionEvent.requestPermission === "function") {
          try {
            const permission = await DeviceMotionEvent.requestPermission();
            updatePermStatus(
              permMotion,
              permission === "granted" ? "granted" : "denied"
            );
          } catch (err) {
            updatePermStatus(permMotion, "denied");
          }
        } else {
          updatePermStatus(permMotion, "granted");
        }
        return true;
      }

      async function requestAllPermissions() {
        permBtn.disabled = true;
        permBtn.textContent = "WAIT...";
        permError.style.display = "none";
        try {
          await requestCameraPermission();
          await requestOrientationPermission();
          await requestMotionPermission();
          permBtn.textContent = "LAUNCHING";
          await new Promise((r) => setTimeout(r, 300));
          permScreen.style.display = "none";
          document.getElementById("character-select").style.display = "flex";
          buildCharacterGrid();
        } catch (err) {
          permError.textContent = err.message;
          permError.style.display = "block";
          permBtn.disabled = false;
          permBtn.textContent = "RETRY";
        }
      }

      permBtn.addEventListener("click", requestAllPermissions);

      // ============================================================
      // CHARACTER SELECTION UI
      // ============================================================
      function buildCharacterGrid() {
        const grid = document.getElementById("char-grid");
        grid.innerHTML = "";

        Object.entries(CHARACTERS).forEach(([key, data]) => {
          const card = document.createElement("div");
          card.className = "char-card";
          card.dataset.key = key;

          const speedPct = data.responsiveness * 250;
          const dmgPct = data.damage * 60;
          const hpPct = (data.health / 140) * 100;

          card.innerHTML = `
            <span class="char-icon">${data.icon}</span>
            <div class="char-name">${data.name}</div>
            <div class="stat-row">
              <span class="stat-label">SPD</span>
              <div class="stat-bar"><div class="stat-fill" style="width:${speedPct}%"></div></div>
            </div>
            <div class="stat-row">
              <span class="stat-label">DMG</span>
              <div class="stat-bar"><div class="stat-fill" style="width:${dmgPct}%"></div></div>
            </div>
            <div class="stat-row">
              <span class="stat-label">HP</span>
              <div class="stat-bar"><div class="stat-fill" style="width:${hpPct}%"></div></div>
            </div>
            <div class="char-trait">${data.traitDesc}</div>
          `;

          card.addEventListener("click", () => selectCharacter(key));
          grid.appendChild(card);
        });
      }

      function selectCharacter(key) {
        playerCharKey = key;
        playerConfig = { ...CHARACTERS[key] };

        document
          .querySelectorAll(".char-card")
          .forEach((c) => c.classList.remove("selected"));
        document.querySelector(`[data-key="${key}"]`).classList.add("selected");

        // --- UPDATED LOGIC: RANDOMIZE BOT ---
        const keys = Object.keys(CHARACTERS);
        botCharKey = keys[Math.floor(Math.random() * keys.length)];
        const baseBotConfig = CHARACTERS[botCharKey];

        if (botCharKey === playerCharKey) {
          // Shadow Match: Same char = Dark/Alt version
          botConfig = {
            ...baseBotConfig,
            color: darkenColor(baseBotConfig.color, 0.4),
            colorHex: darkenHexString(baseBotConfig.colorHex, 0.4),
            isAlt: true,
          };
        } else {
          // Normal Match: Different char
          botConfig = { ...baseBotConfig, isAlt: false };
        }

        // VS display
        const vsDisplay = document.getElementById("vs-display");
        vsDisplay.style.display = "flex";

        document.getElementById("vs-player").innerHTML = `
          <span class="char-icon">${playerConfig.icon}</span>
          <div class="char-name">${playerConfig.name}</div>
        `;

        const altBadge = botConfig.isAlt
          ? '<div class="alt-badge">SHADOW</div>'
          : "";

        document.getElementById("vs-bot").innerHTML = `
          <span class="char-icon">${botConfig.icon}</span>
          <div class="char-name">${botConfig.name}</div>
          ${altBadge}
        `;

        const btn = document.getElementById("confirm-char-btn");
        btn.disabled = false;
        btn.textContent = "FIGHT!";
        btn.style.background = "var(--neo-accent)";
        btn.style.color = "white";
      }

      document
        .getElementById("confirm-char-btn")
        .addEventListener("click", () => {
          document.getElementById("character-select").style.display = "none";

          // If first run, do init. If restart, just handle logic
          if (!webcamRunning) {
            document.getElementById("loading").style.display = "flex";
            initGame();
          } else {
            handlePostLoadFlow();
          }
        });

      // ============================================================
      // DOM ELEMENTS
      // ============================================================
      const videoElement = document.getElementById("video-feed");
      const bgCanvas = document.getElementById("bg-canvas");
      const bgCtx = bgCanvas.getContext("2d", { alpha: false });
      const mainCanvas = document.getElementById("main-canvas");

      const statusText = document.getElementById("status-text");
      const trackingIndicator = document.getElementById("tracking-indicator");
      const gestureIndicator = document.getElementById("gesture-indicator");
      const ammoIndicator = document.getElementById("ammo-indicator");

      const dbgFps = document.getElementById("dbg-fps");
      const dbgFrameTime = document.getElementById("dbg-frame-time");
      const dbgHand = document.getElementById("dbg-hand");
      const dbgConf = document.getElementById("dbg-conf");
      const dbgGesture = document.getElementById("dbg-gesture");

      const debugPanel = document.getElementById("debug-panel");
      document
        .getElementById("toggle-debug-panel")
        .addEventListener("click", () => {
          debugPanel.style.display =
            debugPanel.style.display === "none" ? "block" : "none";
        });

      const calibrationScreen = document.getElementById("calibration-screen");
      const instructScreen = document.getElementById("instruction-screen");
      const calX = document.getElementById("cal-x");
      const calY = document.getElementById("cal-y");
      const calDepth = document.getElementById("cal-depth");
      const calMirrorBtn = document.getElementById("cal-mirror-btn");
      const finishCalBtn = document.getElementById("finish-cal-btn");
      const startGameBtn = document.getElementById("start-game-btn");

      calX.addEventListener(
        "input",
        (e) => (calibrationX = parseInt(e.target.value))
      );
      calY.addEventListener(
        "input",
        (e) => (calibrationY = parseInt(e.target.value))
      );
      calDepth.addEventListener(
        "input",
        (e) => (depthBias = parseFloat(e.target.value))
      );

      calMirrorBtn.addEventListener("click", () => {
        mirrorMode = !mirrorMode;
        calMirrorBtn.textContent = mirrorMode ? "Mirror: ON" : "Mirror: OFF";
      });

      finishCalBtn.addEventListener("click", () => {
        saveCalibration();
        calibrationScreen.style.display = "none";
        showInstructions();
      });

      function showInstructions() {
        if (playerConfig && playerConfig.trait === "projectile") {
          document.getElementById("special-instruct").innerHTML = `
            <span class="step-icon">üéØ</span>
            <strong>FINGER GUN = AUTO-AIM</strong><br />
            Point like a gun to fire homing projectiles at the enemy!
          `;
        } else {
          document.getElementById("special-instruct").innerHTML = `
            <span class="step-icon">üõ°Ô∏è</span>
            <strong>BLOCK</strong><br />
            Hold your hand steady to block incoming attacks.
          `;
        }
        instructScreen.style.display = "flex";
      }

      startGameBtn.addEventListener("click", () => {
        instructScreen.style.display = "none";
        calibrationPhase = false;
        document.getElementById("ui-layer").style.display = "flex";

        if (playerConfig && playerConfig.trait === "projectile") {
          ammoIndicator.style.display = "block";
        } else {
          ammoIndicator.style.display = "none";
        }

        if (handMeshOcclusion) handMeshOcclusion.setDebugMode(false);
        spawnPending = true;
      });

      document
        .getElementById("toggle-debug-vis")
        .addEventListener("click", function () {
          if (handMeshOcclusion) {
            handMeshOcclusion.showDebug = !handMeshOcclusion.showDebug;
            this.textContent = handMeshOcclusion.showDebug
              ? "Hide Mesh"
              : "Show Mesh";
          }
        });

      document
        .getElementById("toggle-occl")
        .addEventListener("click", function () {
          if (handMeshOcclusion) {
            handMeshOcclusion.setEnabled(!handMeshOcclusion.enabled);
            this.style.background = handMeshOcclusion.enabled
              ? "#cf6859"
              : "#eee";
            this.style.color = handMeshOcclusion.enabled ? "white" : "black";
            this.textContent = handMeshOcclusion.enabled
              ? "Occlusion ON"
              : "Occlusion OFF";
          }
        });

      // ============================================================
      // VIEWPORT & CANVAS
      // ============================================================
      class Viewport {
        constructor() {
          this.x = 0;
          this.y = 0;
          this.width = window.innerWidth;
          this.height = window.innerHeight;
          this.videoWidth = 0;
          this.videoHeight = 0;
          this.screenWidth = window.innerWidth;
          this.screenHeight = window.innerHeight;
        }

        update(videoWidth, videoHeight) {
          if (
            this.videoWidth === videoWidth &&
            this.videoHeight === videoHeight &&
            this.screenWidth === window.innerWidth &&
            this.screenHeight === window.innerHeight
          )
            return false;

          this.videoWidth = videoWidth;
          this.videoHeight = videoHeight;
          this.screenWidth = window.innerWidth;
          this.screenHeight = window.innerHeight;
          if (videoWidth === 0 || videoHeight === 0) return false;

          const videoAspect = videoWidth / videoHeight;
          const screenAspect = this.screenWidth / this.screenHeight;

          if (videoAspect > screenAspect) {
            this.height = this.screenHeight;
            this.width = this.screenHeight * videoAspect;
            this.x = (this.screenWidth - this.width) / 2;
            this.y = 0;
          } else {
            this.width = this.screenWidth;
            this.height = this.screenWidth / videoAspect;
            this.x = 0;
            this.y = (this.screenHeight - this.height) / 2;
          }
          return true;
        }

        toNDC(normX, normY) {
          const screenX = this.x + normX * this.width + calibrationX;
          const screenY = this.y + normY * this.height + calibrationY;
          const ndcX = (screenX / this.screenWidth) * 2 - 1;
          const ndcY = -((screenY / this.screenHeight) * 2 - 1);
          return { x: ndcX, y: ndcY };
        }
      }
      const viewport = new Viewport();

      function updateCanvasSizes() {
        const sw = window.innerWidth;
        const sh = window.innerHeight;
        [bgCanvas, mainCanvas].forEach((c) => {
          c.width = sw;
          c.height = sh;
          c.style.width = sw + "px";
          c.style.height = sh + "px";
        });
      }

      function drawVideoBackground() {
        const vw = videoElement.videoWidth;
        const vh = videoElement.videoHeight;
        if (vw === 0 || vh === 0 || videoElement.readyState < 2) return false;
        viewport.update(vw, vh);
        bgCtx.drawImage(
          videoElement,
          viewport.x,
          viewport.y,
          viewport.width,
          viewport.height
        );
        return true;
      }

      // ============================================================
      // FILTERS
      // ============================================================
      class OneEuroFilter {
        constructor(freq = 60, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
          this.frequency = freq;
          this.minCutoff = minCutoff;
          this.beta = beta;
          this.dCutoff = dCutoff;
          this.xPrev = null;
          this.dxPrev = 0;
          this.lastTime = null;
        }
        filter(x, timestamp = null) {
          if (this.xPrev === null) {
            this.xPrev = x;
            this.lastTime = timestamp;
            return x;
          }
          if (timestamp && this.lastTime) {
            const dt = (timestamp - this.lastTime) / 1000;
            if (dt > 0 && dt < 0.5) this.frequency = 1 / dt;
          }
          this.lastTime = timestamp;
          const dx = (x - this.xPrev) * this.frequency;
          const edx =
            this.smoothingFactor(this.dCutoff) * dx +
            (1 - this.smoothingFactor(this.dCutoff)) * this.dxPrev;
          this.dxPrev = edx;
          const cutoff = this.minCutoff + this.beta * Math.abs(edx);
          const ex =
            this.smoothingFactor(cutoff) * x +
            (1 - this.smoothingFactor(cutoff)) * this.xPrev;
          this.xPrev = ex;
          return ex;
        }
        smoothingFactor(cutoff) {
          const r = (2 * Math.PI * cutoff) / this.frequency;
          return r / (r + 1);
        }
      }

      class OneEuroFilter3D {
        constructor(freq, minCutoff, beta, dCutoff) {
          this.x = new OneEuroFilter(freq, minCutoff, beta, dCutoff);
          this.y = new OneEuroFilter(freq, minCutoff, beta, dCutoff);
          this.z = new OneEuroFilter(freq, minCutoff, beta, dCutoff);
        }
        filter(v, ts) {
          return new THREE.Vector3(
            this.x.filter(v.x, ts),
            this.y.filter(v.y, ts),
            this.z.filter(v.z, ts)
          );
        }
      }

      // ============================================================
      // GESTURE DETECTION
      // ============================================================
      function isFingerGun(landmarks) {
        if (!landmarks || landmarks.length < 21) return false;

        const wrist = landmarks[0];
        const indexTip = landmarks[8];
        const indexPip = landmarks[6];
        const middleTip = landmarks[12];
        const middleMcp = landmarks[9];
        const ringTip = landmarks[16];
        const ringMcp = landmarks[13];
        const pinkyTip = landmarks[20];
        const pinkyMcp = landmarks[17];
        const thumbTip = landmarks[4];

        const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

        const indexDist = dist(indexTip, wrist);
        const indexPipDist = dist(indexPip, wrist);
        const indexExtended = indexDist > indexPipDist * 1.1;

        const middleCurled =
          dist(middleTip, middleMcp) < dist(indexTip, wrist) * 0.6;
        const ringCurled = dist(ringTip, ringMcp) < dist(indexTip, wrist) * 0.6;
        const pinkyCurled =
          dist(pinkyTip, pinkyMcp) < dist(indexTip, wrist) * 0.6;

        const thumbOut = dist(thumbTip, wrist) > 0.1;

        return (
          indexExtended && middleCurled && ringCurled && pinkyCurled && thumbOut
        );
      }

      // ============================================================
      // HAND MESH OCCLUSION
      // ============================================================
      class HandMeshOcclusion {
        constructor(scene, camera) {
          this.scene = scene;
          this.camera = camera;
          this.enabled = true;
          this.showDebug = false;
          this.isVisible = false;
          this.occlusionMaterial = new THREE.MeshBasicMaterial({
            colorWrite: false,
            side: THREE.DoubleSide,
          });
          this.debugMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff9d,
            transparent: true,
            opacity: 0.3,
            wireframe: true,
          });
          this.handGroup = new THREE.Group();
          this.handGroup.renderOrder = -1;
          this.scene.add(this.handGroup);
          this.bones = [];
          this.createBones();
          this.filters = Array(21)
            .fill(null)
            .map(() => new OneEuroFilter3D(60, 1.0, 0.3, 1.0));
          this.positions3D = Array(21)
            .fill(null)
            .map(() => new THREE.Vector3());
        }

        createBones() {
          const pairs = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 4],
            [0, 5],
            [5, 6],
            [6, 7],
            [7, 8],
            [0, 9],
            [9, 10],
            [10, 11],
            [11, 12],
            [0, 13],
            [13, 14],
            [14, 15],
            [15, 16],
            [0, 17],
            [17, 18],
            [18, 19],
            [19, 20],
            [5, 9],
            [9, 13],
            [13, 17],
          ];
          // Use CylinderGeometry with high segments for smoothness
          // Radius top, radius bottom, height, radialSegments
          const geo = new THREE.CylinderGeometry(1, 1, 1, 16);
          geo.rotateX(Math.PI / 2);
          pairs.forEach((p) => {
            const m = new THREE.Mesh(geo, this.occlusionMaterial);
            m.userData = { start: p[0], end: p[1] };
            this.handGroup.add(m);
            this.bones.push(m);
          });
        }

        update(landmarks, depth, timestamp, handedness) {
          if (!this.enabled || !landmarks || landmarks.length < 21) {
            this.handGroup.visible = false;
            this.isVisible = false;
            return;
          }
          this.isVisible = true;

          for (let i = 0; i < 21; i++) {
            const lm = landmarks[i];
            const x = mirrorMode ? 1 - lm.x : lm.x;
            const ndc = viewport.toNDC(x, lm.y);
            const pos3D = new THREE.Vector3(ndc.x, ndc.y, 0.5);
            pos3D.unproject(this.camera);
            const dir = pos3D.clone().sub(this.camera.position).normalize();
            const final = this.camera.position
              .clone()
              .add(dir.multiplyScalar(Math.abs(depth)));
            final.add(dir.clone().multiplyScalar((lm.z || 0) * 2));
            const f = this.filters[i].filter(final, timestamp);
            this.positions3D[i].copy(f);
          }

          const p0 = this.positions3D[0];
          const p5 = this.positions3D[5];
          const p17 = this.positions3D[17];
          const v1 = p5.clone().sub(p0);
          const v2 = p17.clone().sub(p0);
          const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
          const viewDir = p0.clone().sub(this.camera.position).normalize();
          let dot = normal.dot(viewDir);
          if (mirrorMode) dot = -dot;

          const isRightHand = handedness === "Right";
          const threshold = 0.15;
          let shouldHide = false;
          if (isRightHand) {
            if (dot > threshold) shouldHide = true;
          } else {
            if (dot < -threshold) shouldHide = true;
          }

          this.handGroup.visible = this.showDebug || !shouldHide;

          // Base thickness scaling based on finger index
          const getFingerBaseThickness = (idx) => {
            if (idx === 0) return 0.5; // Wrist
            if (idx >= 1 && idx <= 4) return 0.45; // Thumb
            if (idx >= 5 && idx <= 8) return 0.4; // Index
            if (idx >= 9 && idx <= 12) return 0.4; // Middle
            if (idx >= 13 && idx <= 16) return 0.38; // Ring
            if (idx >= 17 && idx <= 20) return 0.35; // Pinky
            return 0.3;
          };

          this.bones.forEach((b) => {
            const pA = this.positions3D[b.userData.start];
            const pB = this.positions3D[b.userData.end];
            if (!pA || !pB) return;
            b.position.copy(pA).add(pB).multiplyScalar(0.5);
            b.lookAt(pB);
            const dist = pA.distanceTo(pB);

            // Taper logic: reduce thickness further down the chain
            let baseThick = getFingerBaseThickness(b.userData.start);

            // Further reduce based on position in finger (MCP->PIP->DIP->TIP)
            // Indices: 0, 1->4, 5->8, 9->12, 13->16, 17->20
            const i = b.userData.start;

            // AGGRESSIVE TAPERING LOGIC
            if (i % 4 === 0 && i !== 0) baseThick *= 0.9; // Base
            if (i % 4 === 1 && i !== 1) baseThick *= 0.75; // Middle
            if (i % 4 === 2 && i !== 2) baseThick *= 0.6; // Tip segment
            if (i % 4 === 3 && i !== 3) baseThick *= 0.3; // Tip - Very sharp taper

            // Apply global thinning factor based on depth setting to allow super thin mesh
            // The more negative the depth (further away), the visually smaller it is, but let's also manually scale it
            // scaling factor 0.8 makes everything generally thinner by default
            const userThinning = 0.8;

            const finalThick = baseThick * userThinning;
            // Taper the geometry itself by scaling Z axis heavily for tips?
            // Actually, scaling X/Y handles thickness.
            b.scale.set(finalThick, finalThick, dist);
            b.material = this.showDebug
              ? this.debugMaterial
              : this.occlusionMaterial;
          });
        }

        checkCollision(point, radius) {
          if (!this.isVisible) return false;
          let hit = false;
          this.bones.forEach((b) => {
            const pA = this.positions3D[b.userData.start];
            const pB = this.positions3D[b.userData.end];
            if (!pA || !pB) return;
            const AP = point.clone().sub(pA);
            const AB = pB.clone().sub(pA);
            const t = Math.max(0, Math.min(1, AP.dot(AB) / AB.lengthSq()));
            const close = pA.clone().add(AB.multiplyScalar(t));
            const dist = point.distanceTo(close);
            const minDist = radius + (b.userData.start === 0 ? 0.4 : 0.3);
            if (dist < minDist && dist > 0.001) {
              const push = minDist - dist;
              point.add(
                point.clone().sub(close).normalize().multiplyScalar(push)
              );
              hit = true;
            }
          });
          return hit;
        }

        setEnabled(e) {
          this.enabled = e;
          if (!e) {
            this.handGroup.visible = false;
            this.isVisible = false;
          }
        }
        setDebugMode(d) {
          this.showDebug = d;
        }
      }

      // ============================================================
      // HAND TRACKER
      // ============================================================
      class HandTracker {
        constructor() {
          this.wristFilter = new OneEuroFilter3D(60, 1.5, 0.5, 1.0);
          this.tipFilter = new OneEuroFilter3D(60, 1.5, 0.5, 1.0);
          this.depthFilter = new OneEuroFilter(60, 0.8, 0.3, 1.0);
          this.calSamples = [];
          this.calDepthScale = 0.15;
          this.lastDepth = -8;
        }

        addCalibrationSample(lm) {
          const d1 = Math.hypot(lm[0].x - lm[5].x, lm[0].y - lm[5].y);
          const d2 = Math.hypot(lm[0].x - lm[17].x, lm[0].y - lm[17].y);
          this.calSamples.push((d1 + d2) / 2);
          if (this.calSamples.length >= 20) {
            const sorted = [...this.calSamples]
              .sort((a, b) => a - b)
              .slice(3, -3);
            this.calDepthScale =
              sorted.reduce((a, b) => a + b, 0) / sorted.length;
            return true;
          }
          return false;
        }

        update(lm, ts, cam) {
          if (!lm || lm.length < 21)
            return { isTracking: false, confidence: 0, depth: this.lastDepth };

          const rawD =
            (Math.hypot(lm[0].x - lm[5].x, lm[0].y - lm[5].y) +
              Math.hypot(lm[0].x - lm[17].x, lm[0].y - lm[17].y)) /
            2;
          let d = -6 * (this.calDepthScale / (rawD + 0.001)) + depthBias;
          d = Math.max(-35, Math.min(-3, d));
          d = this.depthFilter.filter(d, ts);
          this.lastDepth = d;

          const unproj = (l, depth) => {
            const x = mirrorMode ? 1 - l.x : l.x;
            const ndc = viewport.toNDC(x, l.y);
            const v = new THREE.Vector3(ndc.x, ndc.y, 0.5);
            v.unproject(cam);
            const dir = v.sub(cam.position).normalize();
            return cam.position
              .clone()
              .add(dir.multiplyScalar(Math.abs(depth)));
          };

          return {
            wrist: this.wristFilter.filter(unproj(lm[0], d), ts),
            tip: this.tipFilter.filter(unproj(lm[12], d), ts),
            indexTip: unproj(lm[8], d),
            depth: d,
            confidence: 1,
            isTracking: true,
          };
        }
      }
      const handTracker = new HandTracker();

      // ============================================================
      // GAME CONFIG & STATE
      // ============================================================
      const CONFIG = {
        gravity: -0.05,
        friction: 0.85,
        sausageRadius: 0.5,
        segmentLen: 0.5,
        damageThreshold: 0.15,
        botAggro: 0.8,
        floorY: -80,
        botDist: 16,
        iFrames: 800,
        maxHandleSpeed: 4.0,
        maxRange: 20,
      };

      let gameActive = false,
        p1Health = 100,
        p2Health = 100,
        p1MaxHealth = 100,
        p2MaxHealth = 100;
      let locarReady = false,
        deviceOrientationControls = null;
      let spawnPending = false;
      let startPos = new THREE.Vector3(),
        startDir = new THREE.Vector3(0, 0, -1);
      let handLandmarker = null,
        webcamRunning = false;
      let calibrationPhase = true;

      let projectiles = [];
      const SHOOT_COOLDOWN = 60;

      let particles = [];

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.fov = 60;

      const renderer = new THREE.WebGLRenderer({
        canvas: mainCanvas,
        antialias: false,
        alpha: true,
        powerPreference: "high-performance",
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      const floorGroup = new THREE.Group();
      floorGroup.position.y = CONFIG.floorY;
      scene.add(floorGroup);
      const gridHelper = new THREE.GridHelper(100, 10, 0x00ff9d, 0x111111);
      floorGroup.add(gridHelper);

      let handMeshOcclusion = null;

      // ============================================================
      // PARTICLE SYSTEM
      // ============================================================
      function createParticle(pos, color, size = 0.3) {
        const geo = new THREE.BoxGeometry(size, size, size);
        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        mesh.position.x += (Math.random() - 0.5) * 0.5;
        mesh.position.y += (Math.random() - 0.5) * 0.5;
        mesh.position.z += (Math.random() - 0.5) * 0.5;
        scene.add(mesh);

        particles.push({
          mesh,
          mat,
          life: 20,
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 0.1,
            0.08 + Math.random() * 0.05,
            (Math.random() - 0.5) * 0.1
          ),
        });
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life--;
          p.mesh.position.add(p.vel);
          p.mesh.rotation.x += 0.1;
          p.mesh.rotation.z += 0.1;
          p.mesh.scale.multiplyScalar(0.92);
          p.mat.opacity = p.life / 20;

          if (p.life <= 0) {
            scene.remove(p.mesh);
            p.mesh.geometry.dispose();
            p.mat.dispose();
            particles.splice(i, 1);
          }
        }
      }

      // ============================================================
      // PHYSICS CLASSES
      // ============================================================
      class Point {
        constructor(x, y, z, pin) {
          this.pos = new THREE.Vector3(x, y, z);
          this.oldPos = this.pos.clone();
          this.pinned = pin;
        }
        update() {
          if (this.pinned) return;
          const v = this.pos
            .clone()
            .sub(this.oldPos)
            .multiplyScalar(CONFIG.friction);
          this.oldPos.copy(this.pos);
          this.pos.add(v).y += CONFIG.gravity;
          if (this.pos.y < CONFIG.floorY) {
            this.pos.y = CONFIG.floorY;
            this.oldPos.x = this.pos.x - v.x * 0.5;
            this.oldPos.z = this.pos.z - v.z * 0.5;
          }
        }
      }

      class Stick {
        constructor(p1, p2, len) {
          this.p1 = p1;
          this.p2 = p2;
          this.len = len;
        }
        update() {
          const delta = this.p2.pos.clone().sub(this.p1.pos);
          const dist = delta.length();
          if (dist === 0) return;
          const diff = ((this.len - dist) / dist) * 0.5;
          const offset = delta.multiplyScalar(diff);
          if (!this.p1.pinned) this.p1.pos.sub(offset);
          if (!this.p2.pinned) this.p2.pos.add(offset);
        }
      }

      class Sausage {
        constructor(
          config,
          pos,
          direction = new THREE.Vector3(0, 0, 1),
          isBot = false
        ) {
          this.points = [];
          this.sticks = [];
          this.lastHit = 0;
          this.config = config;
          this.isBot = isBot;
          this.shootCooldown = 0;

          const segs = config.segments || currentProfile.sausageSegments;
          const dir = direction.clone().normalize();

          for (let i = 0; i < segs; i++) {
            const p = pos
              .clone()
              .add(dir.clone().multiplyScalar(i * CONFIG.segmentLen));
            p.y -= i * 0.1;
            this.points.push(new Point(p.x, p.y, p.z, i === 0));
          }

          for (let i = 0; i < segs - 1; i++)
            this.sticks.push(
              new Stick(this.points[i], this.points[i + 1], CONFIG.segmentLen)
            );
          for (let i = 0; i < segs - 2; i++)
            this.sticks.push(
              new Stick(
                this.points[i],
                this.points[i + 2],
                CONFIG.segmentLen * 1.95
              )
            );

          this.mat = new THREE.MeshStandardMaterial({
            color: config.color,
            roughness: 0.3,
            metalness: 0.1,
          });
          this.curve = new THREE.CatmullRomCurve3(
            this.points.map((p) => p.pos)
          );
          this.mesh = new THREE.Mesh(
            new THREE.TubeGeometry(
              this.curve,
              currentProfile.tubeSegments,
              CONFIG.sausageRadius,
              currentProfile.tubeRadialSegments,
              false
            ),
            this.mat
          );
          this.mesh.renderOrder = 1;
          scene.add(this.mesh);

          const cap = new THREE.SphereGeometry(
            CONFIG.sausageRadius * 0.95,
            6,
            6
          );
          // Head now matches the body material (this.mat) instead of being white/black
          this.head = new THREE.Mesh(cap, this.mat);
          this.butt = new THREE.Mesh(cap.clone(), this.mat);
          this.head.renderOrder = 1;
          this.butt.renderOrder = 1;
          scene.add(this.head);
          scene.add(this.butt);
          this.visible = true;
          this.lastVisTime = 0;
        }

        getHeadPos() {
          return this.points[this.points.length - 1].pos;
        }

        // Auto-targeting projectile
        shoot(targetSausage) {
          if (this.config.trait !== "projectile" || this.shootCooldown > 0)
            return;

          const head = this.getHeadPos();

          // Calculate direction towards enemy's head
          let targetPos;
          if (targetSausage) {
            targetPos = targetSausage.getHeadPos().clone();
            // Lead the target slightly based on distance
            const dist = head.distanceTo(targetPos);
            const leadTime = dist * 0.05; // Adjust for projectile speed
            // Add some prediction based on enemy movement
            const enemyVel = targetSausage.points[
              targetSausage.points.length - 1
            ].pos
              .clone()
              .sub(
                targetSausage.points[targetSausage.points.length - 1].oldPos
              );
            targetPos.add(enemyVel.multiplyScalar(leadTime * 10));
          } else {
            // Fallback: shoot forward
            const neck = this.points[this.points.length - 2].pos;
            targetPos = head
              .clone()
              .add(head.clone().sub(neck).normalize().multiplyScalar(10));
          }

          const dir = targetPos.sub(head).normalize().multiplyScalar(0.6);

          // Create projectile with trail
          const projectile = {
            pos: head.clone(),
            vel: dir,
            mesh: new THREE.Mesh(
              new THREE.SphereGeometry(0.25, 8, 8),
              new THREE.MeshBasicMaterial({
                color: this.isBot ? 0x660000 : 0xff3333,
              })
            ),
            trail: [],
            active: true,
            ownerIsBot: this.isBot,
            life: 150,
            target: targetSausage,
            homingStrength: 0.02, // Slight homing
          };
          scene.add(projectile.mesh);
          projectiles.push(projectile);
          this.shootCooldown = SHOOT_COOLDOWN;
        }

        updatePhys() {
          if (this.shootCooldown > 0) this.shootCooldown--;

          this.points.forEach((p) => p.update());
          for (let i = 0; i < currentProfile.physicsIterations; i++)
            this.sticks.forEach((s) => s.update());

          if (this.config.trait === "fire" && Math.random() < 0.3) {
            const head = this.getHeadPos();
            createParticle(head, this.config.color, 0.4);
          }
        }

        updateVis() {
          const inv = Date.now() - this.lastHit < CONFIG.iFrames;
          if (inv && Date.now() - this.lastVisTime > 50) {
            this.visible = !this.visible;
            this.lastVisTime = Date.now();
            this.mesh.visible =
              this.head.visible =
              this.butt.visible =
                this.visible;
          } else if (!inv && !this.visible) {
            this.visible = true;
            this.mesh.visible = this.head.visible = this.butt.visible = true;
          }
          this.points.forEach((p, i) => this.curve.points[i].copy(p.pos));
          this.mesh.geometry.dispose();
          this.mesh.geometry = new THREE.TubeGeometry(
            this.curve,
            currentProfile.tubeSegments,
            CONFIG.sausageRadius,
            currentProfile.tubeRadialSegments,
            false
          );
          this.butt.position.copy(this.points[0].pos);
          this.head.position.copy(this.points[this.points.length - 1].pos);
        }

        setHandle(base, tip) {
          const currBase = this.points[0].pos;
          const dist = base.distanceTo(currBase);
          if (dist > CONFIG.maxHandleSpeed) {
            base = currBase.clone().lerp(base, CONFIG.maxHandleSpeed / dist);
          }

          const distFromCam = base.distanceTo(camera.position);
          if (distFromCam > CONFIG.maxRange) {
            const dirToCam = base.clone().sub(camera.position).normalize();
            base
              .copy(camera.position)
              .add(dirToCam.multiplyScalar(CONFIG.maxRange));
          }

          const dir = tip.clone().sub(base).normalize();
          for (let i = 0; i < 2 && i < this.points.length; i++) {
            this.points[i].pos
              .copy(base)
              .add(dir.multiplyScalar(i * CONFIG.segmentLen));
            this.points[i].pinned = true;
          }
        }

        release() {
          for (let i = 1; i < 2; i++) this.points[i].pinned = false;
        }

        dispose() {
          this.mesh.geometry.dispose();
          this.mat.dispose();
          scene.remove(this.mesh);
          scene.remove(this.head);
          scene.remove(this.butt);
        }
      }

      let playerSausage, botSausage;
      const BOT_STATE = { angle: 0, mode: "hover" };

      function rebuildSausages() {
        const p1p = playerSausage
          ? playerSausage.points[0].pos.clone()
          : new THREE.Vector3(0, -2, -5);
        const p2p = botSausage
          ? botSausage.points[0].pos.clone()
          : startPos
              .clone()
              .add(startDir.clone().multiplyScalar(CONFIG.botDist));
        const botDir = camera.position.clone().sub(p2p).normalize();

        if (playerSausage) playerSausage.dispose();
        if (botSausage) botSausage.dispose();

        playerSausage = new Sausage(
          playerConfig,
          p1p,
          new THREE.Vector3(0, 0, -1),
          false
        );
        botSausage = new Sausage(botConfig, p2p, botDir, true);
      }

      function updateBot() {
        if (!gameActive || !botSausage) return;
        BOT_STATE.angle += 0.02;
        const pHead = playerSausage.points[playerSausage.points.length - 1].pos;
        const bBase = botSausage.points[0];

        const worldDir = new THREE.Vector3();
        camera.getWorldDirection(worldDir);
        worldDir.y = 0;
        worldDir.normalize();

        const home = camera.position
          .clone()
          .add(worldDir.multiplyScalar(CONFIG.botDist));
        home.y = Math.max(camera.position.y - 2, CONFIG.floorY + 5);

        let target = home.clone();
        let aggro = CONFIG.botAggro;

        if (Math.random() < 0.02) {
          BOT_STATE.mode = "attack";
          setTimeout(() => (BOT_STATE.mode = "retreat"), 800);
        }
        if (BOT_STATE.mode === "attack") {
          aggro = 0.15;
          target.copy(pHead).y += 2;
        } else if (BOT_STATE.mode === "retreat") {
          target.add(worldDir.clone().multiplyScalar(2));
          aggro = 0.03;
          if (Math.random() < 0.05) BOT_STATE.mode = "hover";
        } else {
          const right = new THREE.Vector3(0, 1, 0).cross(worldDir).normalize();
          target.add(right.multiplyScalar(Math.sin(BOT_STATE.angle) * 5));
          target.y += Math.cos(BOT_STATE.angle * 1.5) * 2;
        }
        target.y = Math.max(target.y, CONFIG.floorY + 2);
        bBase.pos.lerp(target, aggro);
        bBase.pinned = true;

        const aim = pHead.clone().sub(bBase.pos).normalize();
        if (aim.lengthSq() > 0.001) {
          botSausage.points[1].pos.copy(
            bBase.pos.clone().add(aim.multiplyScalar(CONFIG.segmentLen))
          );
          botSausage.points[1].pinned = true;
        }

        // Bot shooting with auto-aim at player
        if (
          botConfig.trait === "projectile" &&
          botSausage.shootCooldown <= 0 &&
          Math.random() < 0.015
        ) {
          botSausage.shoot(playerSausage);
        }
      }

      function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          if (!p.active) continue;

          // Slight homing towards target
          if (p.target && p.homingStrength > 0) {
            const targetHead = p.target.getHeadPos();
            const toTarget = targetHead.clone().sub(p.pos).normalize();
            p.vel.lerp(
              toTarget.multiplyScalar(p.vel.length()),
              p.homingStrength
            );
          }

          p.pos.add(p.vel);
          p.mesh.position.copy(p.pos);
          p.mesh.rotation.x += 0.15;
          p.mesh.rotation.z += 0.15;
          p.life--;

          // Trail particles
          if (p.life % 3 === 0) {
            createParticle(
              p.pos.clone(),
              p.ownerIsBot ? 0x440000 : 0xff6666,
              0.15
            );
          }

          const target = p.ownerIsBot ? playerSausage : botSausage;
          if (target) {
            for (let pt of target.points) {
              if (p.pos.distanceTo(pt.pos) < CONFIG.sausageRadius + 0.35) {
                const dmg =
                  12 * (p.ownerIsBot ? botConfig.damage : playerConfig.damage);
                if (p.ownerIsBot) {
                  if (Date.now() - playerSausage.lastHit > CONFIG.iFrames) {
                    p1Health -= dmg;
                    playerSausage.lastHit = Date.now();
                    showDamage(Math.round(dmg), pt.pos, playerConfig.colorHex);
                  }
                } else {
                  if (Date.now() - botSausage.lastHit > CONFIG.iFrames) {
                    p2Health -= dmg;
                    botSausage.lastHit = Date.now();
                    showDamage(Math.round(dmg), pt.pos, "#ffffff");
                  }
                }
                p.life = 0;
                break;
              }
            }
          }

          if (p.life <= 0 || p.pos.y < CONFIG.floorY) {
            p.active = false;
            scene.remove(p.mesh);
            p.mesh.geometry.dispose();
            p.mesh.material.dispose();
          }
        }
        projectiles = projectiles.filter((p) => p.active);
      }

      async function initGame() {
        statusText.innerText = "LOADING AI MODELS...";
        videoElement.srcObject = cameraStream;
        await new Promise((resolve) => {
          videoElement.onloadedmetadata = () =>
            videoElement.play().then(resolve);
        });

        webcamRunning = true;
        updateCanvasSizes();
        initLocAR();
        handMeshOcclusion = new HandMeshOcclusion(scene, camera);

        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.3,
          minHandPresenceConfidence: 0.3,
          minTrackingConfidence: 0.3,
        });

        document.getElementById("loading").style.display = "none";
        handMeshOcclusion.setDebugMode(true);

        animate();
        handlePostLoadFlow();
      }

      // Logic to decide whether to show calibration or skip to instructions
      function handlePostLoadFlow() {
        const hasCal = loadCalibration();
        if (hasCal && !forceRecalibrate) {
          // Skip calibration, go straight to instructions/start
          calibrationPhase = false;
          showInstructions();
        } else {
          // Show calibration
          document.getElementById("calibration-screen").style.display = "flex";
          calibrationPhase = true;
          handMeshOcclusion.setDebugMode(true);
        }
      }

      function initLocAR() {
        deviceOrientationControls = new LocAR.DeviceOrientationControls(camera);
        deviceOrientationControls.on("deviceorientationgranted", (ev) => {
          ev.target.connect();
          locarReady = true;
        });
        deviceOrientationControls.init();
      }

      function spawnEntities() {
        const wd = new THREE.Vector3();
        camera.getWorldDirection(wd);
        wd.y = 0;
        wd.normalize();
        startDir.copy(wd);
        startPos.copy(camera.position);

        const sp = startPos
          .clone()
          .add(startDir.clone().multiplyScalar(CONFIG.botDist));
        sp.y = -2;

        playerSausage = new Sausage(
          playerConfig,
          new THREE.Vector3(0, -2, -5),
          new THREE.Vector3(0, 0, -1),
          false
        );
        const botDir = camera.position.clone().sub(sp).normalize();
        botSausage = new Sausage(botConfig, sp, botDir, true);

        p1MaxHealth = p1Health = playerConfig.health;
        p2MaxHealth = p2Health = botConfig.health;

        document.getElementById("p1-name").textContent =
          playerConfig.name.toUpperCase();

        // Show proper name for bot (add ALT tag if needed)
        const botName = botConfig.isAlt
          ? botConfig.name.toUpperCase() + " (ALT)"
          : botConfig.name.toUpperCase();
        document.getElementById("p2-name").textContent = botName;

        document.getElementById("p1-bar").style.background =
          playerConfig.colorHex;
        document.getElementById("p2-bar").style.background = botConfig.colorHex;

        spawnPending = false;
        gameActive = true;
      }

      function checkCollisions() {
        if (!gameActive || !playerSausage || !botSausage) return;
        const p1 = playerSausage,
          p2 = botSausage;
        if (p1.points[0].pos.distanceTo(p2.points[0].pos) > 30) return;

        if (handMeshOcclusion && handMeshOcclusion.isVisible) {
          p2.points.forEach((pt) => {
            if (!pt.pinned)
              handMeshOcclusion.checkCollision(pt.pos, CONFIG.sausageRadius);
          });
        }

        const dmgCap = 25;
        const minD = CONFIG.sausageRadius * 1.8;
        for (let i = 0; i < p1.points.length; i += 3) {
          for (let j = 0; j < p2.points.length; j += 3) {
            const pt1 = p1.points[i],
              pt2 = p2.points[j];
            const dist = pt1.pos.distanceTo(pt2.pos);
            if (dist < minD && dist > 0) {
              const push = ((minD - dist) * 0.5) / dist;
              const delta = pt1.pos.clone().sub(pt2.pos);
              if (!pt1.pinned) pt1.pos.add(delta.multiplyScalar(push));
              if (!pt2.pinned) pt2.pos.sub(delta.multiplyScalar(push));

              const v1 = pt1.pos.clone().sub(pt1.oldPos).length();
              const v2 = pt2.pos.clone().sub(pt2.oldPos).length();
              const total = v1 + v2;
              if (total > CONFIG.damageThreshold) {
                const isHead1 = i >= p1.points.length - 4;
                const isHead2 = j >= p2.points.length - 4;
                const now = Date.now();
                if (isHead1 || isHead2) {
                  if (v1 > v2 && now - p2.lastHit > CONFIG.iFrames) {
                    const dmg = Math.min(
                      Math.floor(total * 50 * playerConfig.damage),
                      dmgCap
                    );
                    p2Health -= dmg;
                    p2.lastHit = now;
                    showDamage(Math.round(dmg), pt2.pos, "#ffffff");
                  } else if (v2 > v1 && now - p1.lastHit > CONFIG.iFrames) {
                    const dmg = Math.min(
                      Math.floor(total * 50 * botConfig.damage),
                      dmgCap
                    );
                    p1Health -= dmg;
                    p1.lastHit = now;
                    showDamage(dmg, pt1.pos, botConfig.colorHex);
                  }
                }
              }
            }
          }
        }
        p1Health = Math.max(0, p1Health);
        p2Health = Math.max(0, p2Health);
        document.getElementById("p1-bar").style.width =
          (p1Health / p1MaxHealth) * 100 + "%";
        document.getElementById("p2-bar").style.width =
          (p2Health / p2MaxHealth) * 100 + "%";
        if (p1Health <= 0 || p2Health <= 0) gameOver();
      }

      function showDamage(amt, pos, col) {
        const div = document.createElement("div");
        div.className = "dmg-text";
        div.innerText = amt;
        div.style.color = col;
        const v = pos.clone().project(camera);
        div.style.left = ((v.x + 1) / 2) * window.innerWidth + "px";
        div.style.top = ((1 - v.y) / 2) * window.innerHeight + "px";
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1000);
      }

      function gameOver() {
        gameActive = false;
        document.getElementById("win-screen").style.display = "flex";
        const msg = document.getElementById("win-msg");
        msg.innerText = p1Health > 0 ? "VICTORY" : "WASTED";
        msg.style.color =
          p1Health > 0 ? "var(--neo-success)" : "var(--neo-danger)";
      }

      // RESET / REMATCH LOGIC
      function resetGame() {
        gameActive = false;
        // Hide Win Screen
        document.getElementById("win-screen").style.display = "none";
        // Hide HUD
        document.getElementById("ui-layer").style.display = "none";

        // Clean up old physics objects
        if (playerSausage) {
          playerSausage.dispose();
          playerSausage = null;
        }
        if (botSausage) {
          botSausage.dispose();
          botSausage = null;
        }

        // Clean projectiles & particles
        projectiles.forEach((p) => {
          if (p.mesh) scene.remove(p.mesh);
        });
        projectiles = [];
        particles.forEach((p) => {
          if (p.mesh) scene.remove(p.mesh);
        });
        particles = [];

        // Show Character Select again
        document.getElementById("character-select").style.display = "flex";
      }

      document.getElementById("rematch-btn").addEventListener("click", () => {
        resetGame();
      });

      let frameCount = 0,
        lastFps = 0,
        lastHand = 0;
      let currentLandmarks = null;
      let fingerGunActive = false;
      let fingerGunCooldown = 0;

      function animate() {
        requestAnimationFrame(animate);
        const now = performance.now();
        frameCount++;
        if (now - lastFps > 500) {
          dbgFps.innerText = Math.round((frameCount * 1000) / (now - lastFps));
          dbgFrameTime.innerText = (now - lastFps / frameCount).toFixed(1);
          frameCount = 0;
          lastFps = now;
        }

        drawVideoBackground();
        if (deviceOrientationControls && locarReady)
          deviceOrientationControls.update();

        if (fingerGunCooldown > 0) fingerGunCooldown--;

        if (now - lastHand > currentProfile.handInterval) {
          if (webcamRunning && handLandmarker) {
            const res = handLandmarker.detectForVideo(videoElement, now);
            currentLandmarks = res.landmarks?.[0];
            const track = handTracker.update(currentLandmarks, now, camera);

            if (track.confidence > 0.8) {
              trackingIndicator.className = "tracking-good";
              trackingIndicator.innerText = "HAND DETECTED";
            } else if (track.confidence > 0.3) {
              trackingIndicator.className = "tracking-ok";
              trackingIndicator.innerText = "WEAK SIGNAL";
            } else {
              trackingIndicator.className = "tracking-lost";
              trackingIndicator.innerText = "NO HAND";
            }

            if (calibrationPhase && currentLandmarks)
              handTracker.addCalibrationSample(currentLandmarks);

            const handedness = res.handedness?.[0]?.[0]?.categoryName;
            if (handMeshOcclusion)
              handMeshOcclusion.update(
                currentLandmarks,
                track.depth,
                now,
                handedness
              );

            const isGun = isFingerGun(currentLandmarks);
            fingerGunActive = isGun;

            if (isGun) {
              gestureIndicator.style.display = "block";
              dbgGesture.innerText = "üëÜ GUN";
            } else {
              gestureIndicator.style.display = "none";
              dbgGesture.innerText = "-";
            }

            if (gameActive) {
              if (track.isTracking && playerSausage) {
                const center = track.wrist.clone().lerp(track.tip, 0.75);
                playerSausage.setHandle(center, track.tip);

                // Finger gun auto-aim shooting for Salami
                if (playerConfig.trait === "projectile") {
                  if (
                    isGun &&
                    fingerGunCooldown <= 0 &&
                    playerSausage.shootCooldown <= 0
                  ) {
                    playerSausage.shoot(botSausage); // Auto-target bot
                    fingerGunCooldown = 30;
                  }

                  if (playerSausage.shootCooldown > 0) {
                    ammoIndicator.className = "cooldown";
                    ammoIndicator.textContent = `‚è≥ RELOADING (${Math.ceil(playerSausage.shootCooldown / 10)})`;
                  } else {
                    ammoIndicator.className = "ready";
                    ammoIndicator.textContent = "üéØ AUTO-AIM READY";
                  }
                }
              } else if (playerSausage) {
                playerSausage.release();
                const f = new THREE.Vector3(0, -4, -6)
                  .applyQuaternion(camera.quaternion)
                  .add(camera.position);
                playerSausage.points[0].pos.lerp(f, 0.05);
                playerSausage.points[0].pinned = true;
              }
            }
            if (frameCount % 10 === 0) {
              dbgHand.innerText = track.isTracking ? "Yes" : "No";
              dbgConf.innerText = Math.round(track.confidence * 100) + "%";
            }
          }
          lastHand = now;
        }

        if (spawnPending && !calibrationPhase) spawnEntities();

        if (gameActive) {
          updateBot();
          if (playerSausage) {
            playerSausage.updatePhys();
            playerSausage.updateVis();
          }
          if (botSausage) {
            botSausage.updatePhys();
            botSausage.updateVis();
          }
          updateProjectiles();
          updateParticles();
          checkCollisions();
        }

        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateCanvasSizes();
        viewport.update(videoElement.videoWidth, videoElement.videoHeight);
      });
    </script>
  </body>
</html>
